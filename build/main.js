/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/director.ts":
/*!*************************!*\
  !*** ./src/director.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Director: () => (/* binding */ Director)\n/* harmony export */ });\n/* harmony import */ var _gl_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl/scene */ \"./src/gl/scene.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _objects_kart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objects/kart */ \"./src/objects/kart.ts\");\n/* harmony import */ var _objects_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./objects/player */ \"./src/objects/player.ts\");\n/* harmony import */ var _objects_camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./objects/camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _objects_test__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./objects/test */ \"./src/objects/test.ts\");\n/* harmony import */ var _util_objLoader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/objLoader */ \"./src/util/objLoader.ts\");\n/* harmony import */ var _objects_stage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects/stage */ \"./src/objects/stage.ts\");\n\n\n\n\n\n\n\n\nclass Director {\n    canvas;\n    canvasW;\n    canvasH;\n    gl;\n    scene;\n    keysDown;\n    keysHeld;\n    keysHeldPrev;\n    objects;\n    constructor() {\n        this.canvas = document.getElementById(\"canvasMain\");\n        this.canvasW = this.canvasH = 0;\n        this.resize();\n        this.gl = this.canvas.getContext(\"webgl\", { stencil: true });\n        this.scene = new _gl_scene__WEBPACK_IMPORTED_MODULE_0__.Scene(this.gl);\n        this.keysDown = new Set();\n        this.keysHeld = new Set();\n        this.keysHeldPrev = new Set();\n        this.objects = [];\n        this.init();\n    }\n    resize() {\n        const rect = this.canvas.getBoundingClientRect();\n        this.canvasW = rect.width;\n        this.canvasH = rect.height;\n        this.canvas.width = rect.width;\n        this.canvas.height = rect.height;\n    }\n    async init() {\n        const trackFile = await fetch(\"assets/track.obj\").then(t => t.arrayBuffer());\n        const trackModel = _util_objLoader__WEBPACK_IMPORTED_MODULE_6__.ObjLoader.makeModelBuilder(trackFile);\n        this.objects = [];\n        const player = new _objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart();\n        this.objectAdd(player);\n        const camera = new _objects_camera__WEBPACK_IMPORTED_MODULE_4__.Camera();\n        camera.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](2, 4, -4);\n        this.objectAdd(camera);\n        const stage = new _objects_stage__WEBPACK_IMPORTED_MODULE_7__.Stage();\n        stage.setModel(this.gl, trackModel);\n        this.objectAdd(stage);\n        const test = new _objects_test__WEBPACK_IMPORTED_MODULE_5__.Test();\n        test.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, -1.25);\n        //this.objectAdd(test)\n    }\n    objectAdd(object) {\n        object.director = this;\n        object.init();\n        this.objects.push(object);\n    }\n    objectDestroy(object) {\n        this.objects = this.objects.filter(obj => obj !== object);\n    }\n    objectFind(typ) {\n        for (const object of this.objects) {\n            if (object instanceof typ)\n                return object;\n        }\n        return null;\n    }\n    objectWith(typ, fn) {\n        for (const object of this.objects) {\n            if (object instanceof typ) {\n                fn(object);\n            }\n        }\n    }\n    process() {\n        this.keysDown.clear();\n        for (const key of this.keysHeld) {\n            if (!this.keysHeldPrev.has(key))\n                this.keysDown.add(key);\n        }\n        if (this.keysDown.has(\"t\")) {\n            const kart = this.objectFind(_objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart);\n            const player = this.objectFind(_objects_player__WEBPACK_IMPORTED_MODULE_3__.Player);\n            const test = this.objectFind(_objects_test__WEBPACK_IMPORTED_MODULE_5__.Test);\n            if (kart) {\n                this.objectDestroy(kart);\n                const newPlayer = new _objects_player__WEBPACK_IMPORTED_MODULE_3__.Player();\n                newPlayer.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, -1.25);\n                this.objectAdd(newPlayer);\n            }\n            else if (player) {\n                this.objectDestroy(player);\n                const newTest = new _objects_test__WEBPACK_IMPORTED_MODULE_5__.Test();\n                newTest.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, -1.25);\n                this.objectAdd(newTest);\n            }\n            else if (test) {\n                this.objectDestroy(test);\n                const newKart = new _objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart();\n                this.objectAdd(newKart);\n            }\n        }\n        for (const object of this.objects)\n            object.process();\n        this.keysHeldPrev.clear();\n        for (const key of this.keysHeld)\n            this.keysHeldPrev.add(key);\n    }\n    render() {\n        this.scene.begin();\n        this.scene.viewport(0, 0, this.canvasW, this.canvasH);\n        this.scene.clear(0, 0, 0, 1, 1);\n        this.objectWith(_objects_camera__WEBPACK_IMPORTED_MODULE_4__.Camera, (c) => c.setMatrices());\n        for (const object of this.objects)\n            object.render();\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/director.ts?");

/***/ }),

/***/ "./src/gl/buffer.ts":
/*!**************************!*\
  !*** ./src/gl/buffer.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLBuffer: () => (/* binding */ GLBuffer)\n/* harmony export */ });\nclass GLBuffer {\n    id;\n    count;\n    static makePosition(gl, positions) {\n        return GLBuffer.make(gl, positions);\n    }\n    static makeNormal(gl, normals) {\n        return GLBuffer.make(gl, normals);\n    }\n    static makeColor(gl, colors) {\n        return GLBuffer.make(gl, colors);\n    }\n    static make(gl, data) {\n        let buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n        return new GLBuffer(buffer, data.length);\n    }\n    constructor(id, count) {\n        this.id = id;\n        this.count = count;\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/gl/buffer.ts?");

/***/ }),

/***/ "./src/gl/model.ts":
/*!*************************!*\
  !*** ./src/gl/model.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GfxModel)\n/* harmony export */ });\nclass GfxModel {\n    positions;\n    normals;\n    colors;\n    setPositions(positions) {\n        this.positions = positions;\n        return this;\n    }\n    setNormals(normals) {\n        this.normals = normals;\n        return this;\n    }\n    setColors(colors) {\n        this.colors = colors;\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/gl/model.ts?");

/***/ }),

/***/ "./src/gl/scene.ts":
/*!*************************!*\
  !*** ./src/gl/scene.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader */ \"./src/gl/shader.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n\n\n\n\nclass Scene {\n    gl;\n    matProjection;\n    matView;\n    matTransformStack;\n    modelPoint;\n    modelPath;\n    modelArrow;\n    material;\n    materialColor;\n    materialUnshaded;\n    matrixCache;\n    matrixCachePointer;\n    matrixCacheUtilization;\n    matrixCacheUtilizationTotal;\n    constructor(gl) {\n        this.gl = gl;\n        this.matProjection = null;\n        this.matView = null;\n        this.matTransformStack = [_math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity()];\n        this.modelPoint = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__[\"default\"]()\n            .addSphere(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 4)\n            .calculateNormals()\n            .makeModel(gl);\n        this.modelPath = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__[\"default\"]()\n            .addCylinder(-0.5, -0.5, 0, 0.5, 0.5, 1, 16)\n            .calculateNormals()\n            .makeModel(gl);\n        this.modelArrow = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__[\"default\"]()\n            .addCone(-0.5, -0.5, -1, 0.5, 0.5, 0, 16)\n            .calculateNormals()\n            .makeModel(gl);\n        this.material = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrc, fragmentSrc)\n            .registerLocations(gl, [\"aPosition\", \"aNormal\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uAmbientColor\", \"uDiffuseColor\"]);\n        this.materialColor = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrcColor, fragmentSrcColor)\n            .registerLocations(gl, [\"aPosition\", \"aNormal\", \"aColor\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uAmbientColor\", \"uDiffuseColor\", \"uFogDensity\"]);\n        this.materialUnshaded = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrc, fragmentSrcUnshaded)\n            .registerLocations(gl, [\"aPosition\", \"aNormal\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uDiffuseColor\"]);\n        this.gl.enable(this.gl.DEPTH_TEST);\n        this.gl.enable(this.gl.CULL_FACE);\n        this.gl.depthFunc(this.gl.LEQUAL);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.matrixCache = [];\n        this.matrixCachePointer = 0;\n        this.matrixCacheUtilization = 0;\n        this.matrixCacheUtilizationTotal = 0;\n    }\n    begin() {\n        //if (this.matrixCacheUtilization < this.matrixCacheUtilizationTotal)\n        //\tconsole.log(\"last frame cache utilization: \" + this.matrixCacheUtilization + \" / \" + this.matrixCacheUtilizationTotal)\n        this.matTransformStack.splice(1, this.matTransformStack.length);\n        this.matrixCachePointer = 0;\n        this.matrixCacheUtilization = 0;\n        this.matrixCacheUtilizationTotal = 0;\n    }\n    viewport(x, y, w, h) {\n        this.gl.viewport(x, y, w, h);\n    }\n    clear(r = 0, g = 0, b = 0, a = 1, depth = 1) {\n        this.gl.clearColor(r, g, b, a);\n        this.gl.clearDepth(depth);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n    }\n    clearDepth(depth = 1) {\n        this.gl.clearDepth(depth);\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\n    }\n    setProjection(matrix) {\n        this.matProjection = matrix;\n        let materials = [\n            this.material,\n            this.materialColor,\n            this.materialUnshaded,\n        ];\n        for (const mat of materials) {\n            mat.use(this.gl);\n            mat.setMat4(this.gl, \"uMatProj\", this.matProjection);\n        }\n    }\n    setView(matrix) {\n        this.matView = matrix;\n        let materials = [\n            this.material,\n            this.materialColor,\n            this.materialUnshaded,\n        ];\n        for (const mat of materials) {\n            mat.use(this.gl);\n            mat.setMat4(this.gl, \"uMatView\", this.matView);\n            mat.setVec4(this.gl, \"uAmbientColor\", [0.5, 0.5, 0.5, 1]);\n        }\n    }\n    saveCache(newCache) {\n        if (this.matrixCachePointer < this.matrixCache.length) {\n            this.matrixCache[this.matrixCachePointer] = newCache;\n            this.matrixCachePointer++;\n        }\n        else {\n            this.matrixCache.push(newCache);\n            this.matrixCachePointer = this.matrixCache.length;\n        }\n    }\n    pushMatrix(matrix) {\n        this.matTransformStack.push(this.matTransformStack[this.matTransformStack.length - 1].mul(matrix));\n    }\n    popMatrix() {\n        this.matTransformStack.pop();\n    }\n    pushTranslationScale(pos, scale) {\n        this.matrixCacheUtilizationTotal++;\n        const x = pos.x;\n        const y = pos.y;\n        const z = pos.z;\n        const sx = scale.x;\n        const sy = scale.y;\n        const sz = scale.z;\n        if (this.matrixCachePointer < this.matrixCache.length) {\n            let cache = this.matrixCache[this.matrixCachePointer];\n            if (cache.x === x && cache.y === y && cache.z === z &&\n                cache.sx === sx && cache.sy === sy && cache.sz === sz) {\n                this.matTransformStack.push(cache.matrix);\n                this.matrixCachePointer++;\n                this.matrixCacheUtilization++;\n                return;\n            }\n        }\n        const matrix = this.matTransformStack[this.matTransformStack.length - 1]\n            .mul(_math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale(sx, sy, sz).mul(_math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(x, y, z)));\n        this.saveCache({ x, y, z, sx, sy, sz, matrix });\n        this.matTransformStack.push(matrix);\n    }\n    popTranslationScale() {\n        this.popMatrix();\n    }\n    drawModel(model, material, diffuseColor) {\n        material.use(this.gl);\n        material.bindPosition(this.gl, \"aPosition\", model.positions);\n        material.bindNormals(this.gl, \"aNormal\", model.normals);\n        if (material.hasColor)\n            material.bindColors(this.gl, \"aColor\", model.colors);\n        material.setMat4(this.gl, \"uMatModel\", this.matTransformStack[this.matTransformStack.length - 1]);\n        material.setVec4(this.gl, \"uDiffuseColor\", diffuseColor);\n        material.drawTriangles(this.gl, model.positions.count / 3);\n    }\n    drawArrow(pos1, pos2, scale, color) {\n        this.matrixCacheUtilizationTotal++;\n        let hadCache = false;\n        let matrixLine = null;\n        let matrixArrow = null;\n        if (this.matrixCachePointer < this.matrixCache.length) {\n            let cache = this.matrixCache[this.matrixCachePointer];\n            if (cache.x1 === pos1.x && cache.y1 === pos1.y && cache.z1 === pos1.z &&\n                cache.x2 === pos2.x && cache.y2 === pos2.y && cache.z2 === pos2.z &&\n                cache.scale === scale) {\n                matrixLine = cache.matrixLine;\n                matrixArrow = cache.matrixArrow;\n                this.matrixCachePointer++;\n                this.matrixCacheUtilization++;\n                hadCache = true;\n            }\n        }\n        if (matrixLine === null || matrixArrow === null) {\n            let matrixScale = _math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale(scale, scale, pos2.sub(pos1).magn() - scale * 2);\n            let matrixAlign = _math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 1), pos2.sub(pos1).normalized());\n            let matrixTranslate = _math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(pos1.x, pos1.y, pos1.z);\n            let matrixScaleArrow = _math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale(scale * 2, scale * 2, scale * 2);\n            let matrixTranslateArrow = _math_mat4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(pos2.x, pos2.y, pos2.z);\n            matrixLine = this.matTransformStack[this.matTransformStack.length - 1]\n                .mul(matrixScale.mul(matrixAlign.mul(matrixTranslate)));\n            matrixArrow = this.matTransformStack[this.matTransformStack.length - 1]\n                .mul(matrixScaleArrow.mul(matrixAlign.mul(matrixTranslateArrow)));\n        }\n        this.matTransformStack.push(matrixLine);\n        this.drawModel(this.modelPath, this.material, color);\n        this.matTransformStack.pop();\n        this.matTransformStack.push(matrixArrow);\n        this.drawModel(this.modelArrow, this.material, color);\n        this.matTransformStack.pop();\n        if (!hadCache) {\n            const newCache = {\n                x1: pos1.x, y1: pos1.y, z1: pos1.z,\n                x2: pos2.x, y2: pos2.y, z2: pos2.z,\n                scale,\n                matrixLine, matrixArrow,\n            };\n            this.saveCache(newCache);\n        }\n    }\n    doStencilStampPass(fn) {\n        this.gl.enable(this.gl.STENCIL_TEST);\n        this.gl.stencilFunc(this.gl.ALWAYS, 0, 0xff);\n        this.gl.stencilMask(0xff);\n        this.gl.clearStencil(0);\n        this.gl.clear(this.gl.STENCIL_BUFFER_BIT);\n        this.gl.colorMask(false, false, false, false);\n        this.gl.depthMask(false);\n        this.gl.cullFace(this.gl.FRONT);\n        this.gl.stencilOp(this.gl.KEEP, this.gl.INCR, this.gl.KEEP);\n        fn();\n        this.gl.cullFace(this.gl.BACK);\n        this.gl.stencilOp(this.gl.KEEP, this.gl.DECR, this.gl.KEEP);\n        fn();\n        this.gl.cullFace(this.gl.BACK);\n        this.gl.colorMask(true, true, true, true);\n        this.gl.stencilMask(0x00);\n        this.gl.stencilFunc(this.gl.NOTEQUAL, 0, 0xff);\n        fn();\n        this.gl.depthMask(true);\n        this.gl.disable(this.gl.STENCIL_TEST);\n    }\n}\nconst vertexSrc = `\r\n\tprecision highp float;\r\n\t\r\n\tattribute vec4 aPosition;\r\n\tattribute vec4 aNormal;\r\n\r\n\tuniform mat4 uMatModel;\r\n\tuniform mat4 uMatView;\r\n\tuniform mat4 uMatProj;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\r\n\t\tvScreenNormal = uMatView * uMatModel * vec4(aNormal.xyz, 0);\r\n\t\t\r\n\t\tgl_Position = uMatProj * uMatView * uMatModel * aPosition;\r\n\t}`;\nconst fragmentSrc = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\tuniform vec4 uAmbientColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\r\n\t\t\r\n\t\tvec4 ambientColor = uAmbientColor;\r\n\t\tvec4 diffuseColor = uDiffuseColor;\r\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\r\n\t\t\r\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\r\n\t\t\r\n\t\tgl_FragColor = diffuseColor * mix(ambientColor, lightColor, lightIncidence);\r\n\t}`;\nconst vertexSrcColor = `\r\n\tprecision highp float;\r\n\t\r\n\tattribute vec4 aPosition;\r\n\tattribute vec4 aNormal;\r\n\tattribute vec4 aColor;\r\n\r\n\tuniform mat4 uMatModel;\r\n\tuniform mat4 uMatView;\r\n\tuniform mat4 uMatProj;\r\n\t\r\n\tvarying float vDepth;\r\n\tvarying vec4 vWorldPos;\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\tvarying vec4 vColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\r\n\t\tvScreenNormal = uMatModel * uMatView * vec4(aNormal.xyz, 0);\r\n\t\t\r\n\t\tvColor = aColor;\r\n\t\t\r\n\t\tvWorldPos = uMatModel * aPosition;\r\n\t\tvec4 position = uMatProj * uMatView * vWorldPos;\r\n\t\tgl_Position = position;\r\n\t\tvDepth = position.z / position.w;\r\n\t}`;\nconst fragmentSrcColor = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying float vDepth;\r\n\tvarying vec4 vWorldPos;\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\tvarying vec4 vColor;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\tuniform vec4 uAmbientColor;\r\n\tuniform float uFogDensity;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\r\n\t\t\r\n\t\tvec4 ambientColor = uAmbientColor;\r\n\t\tvec4 diffuseColor = uDiffuseColor * vColor;\r\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\r\n\t\t\r\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\r\n\t\t\r\n\t\tfloat patternFactor =\r\n\t\t\tmod(vWorldPos.x, 1.0) > 0.9 ||\r\n\t\t\tmod(vWorldPos.y, 1.0) > 0.9 ||\r\n\t\t\tmod(vWorldPos.z, 1.0) > 0.9 ? 0.0 : 1.0;\r\n\r\n\t\tgl_FragColor =\r\n\t\t\tmix(diffuseColor * vec4(0.85, 0.85, 0.85, 1), diffuseColor, patternFactor) *\r\n\t\t\tmix(ambientColor, lightColor, lightIncidence);\r\n\t}`;\nconst fragmentSrcUnshaded = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tgl_FragColor = uDiffuseColor;\r\n\t}`;\n\n\n//# sourceURL=webpack://platformer/./src/gl/scene.ts?");

/***/ }),

/***/ "./src/gl/shader.ts":
/*!**************************!*\
  !*** ./src/gl/shader.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLProgram: () => (/* binding */ GLProgram),\n/* harmony export */   GLShader: () => (/* binding */ GLShader)\n/* harmony export */ });\nclass GLShader {\n    id;\n    static makeVertex(gl, src) {\n        return GLShader.make(gl, src, gl.VERTEX_SHADER);\n    }\n    static makeFragment(gl, src) {\n        return GLShader.make(gl, src, gl.FRAGMENT_SHADER);\n    }\n    static make(gl, src, kind) {\n        let shader = gl.createShader(kind);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            console.error(\"Error compiling shader: \\n\\n\" + gl.getShaderInfoLog(shader));\n            gl.deleteShader(shader);\n            return null;\n        }\n        return new GLShader(shader);\n    }\n    constructor(id) {\n        this.id = id;\n    }\n}\nclass GLProgram {\n    id;\n    attributes;\n    uniforms;\n    hasColor;\n    static makeFromSrc(gl, vertexSrc, fragmentSrc) {\n        let vertexShader = GLShader.makeVertex(gl, vertexSrc);\n        if (vertexShader == null)\n            throw \"vertexShader null\";\n        let fragmentShader = GLShader.makeFragment(gl, fragmentSrc);\n        if (fragmentShader == null)\n            throw \"fragmentShader null\";\n        return GLProgram.make(gl, vertexShader, fragmentShader);\n    }\n    static make(gl, vertexShader, fragmentShader) {\n        let program = gl.createProgram();\n        gl.attachShader(program, vertexShader.id);\n        gl.attachShader(program, fragmentShader.id);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            console.error(\"Error creating program: \\n\\n\" + gl.getProgramInfoLog(program));\n            gl.deleteProgram(program);\n            throw \"GLProgram.make error\";\n        }\n        return new GLProgram(program);\n    }\n    constructor(id) {\n        this.id = id;\n        this.attributes = {};\n        this.uniforms = {};\n        this.hasColor = false;\n    }\n    registerLocations(gl, attrbs, unifs) {\n        for (let attrb of attrbs)\n            this.attributes[attrb] = gl.getAttribLocation(this.id, attrb);\n        for (let unif of unifs)\n            this.uniforms[unif] = gl.getUniformLocation(this.id, unif);\n        this.hasColor = (attrbs.find(a => a == \"aColor\") != null);\n        return this;\n    }\n    use(gl) {\n        gl.useProgram(this.id);\n        return this;\n    }\n    bindPosition(gl, attrb, buffer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\n        gl.vertexAttribPointer(this.attributes[attrb], 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(this.attributes[attrb]);\n        return this;\n    }\n    bindNormals(gl, attrb, buffer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\n        gl.vertexAttribPointer(this.attributes[attrb], 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(this.attributes[attrb]);\n        return this;\n    }\n    bindColors(gl, attrb, buffer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\n        gl.vertexAttribPointer(this.attributes[attrb], 4, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(this.attributes[attrb]);\n        return this;\n    }\n    setFloat(gl, unif, x) {\n        gl.uniform1f(this.uniforms[unif], x);\n        return this;\n    }\n    setMat4(gl, unif, matrix) {\n        gl.uniformMatrix4fv(this.uniforms[unif], false, matrix.asFloat32Array());\n        return this;\n    }\n    setVec4(gl, unif, vec) {\n        gl.uniform4fv(this.uniforms[unif], new Float32Array(vec));\n        return this;\n    }\n    drawTriangles(gl, count, offset = 0) {\n        gl.drawArrays(gl.TRIANGLES, offset, count);\n        return this;\n    }\n    drawTriangleStrip(gl, count, offset = 0) {\n        gl.drawArrays(gl.TRIANGLE_STRIP, offset, count);\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/gl/shader.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _director__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./director */ \"./src/director.ts\");\n\nmain();\nfunction main() {\n    const director = new _director__WEBPACK_IMPORTED_MODULE_0__.Director();\n    const render = () => {\n        director.process();\n        director.render();\n    };\n    window.addEventListener(\"keydown\", (ev) => {\n        director.keysHeld.add(ev.key.toLowerCase());\n    });\n    window.addEventListener(\"keyup\", (ev) => {\n        director.keysHeld.delete(ev.key.toLowerCase());\n    });\n    renderLoop(render);\n}\nfunction renderLoop(fn) {\n    fn();\n    //setTimeout(() => renderLoop(fn), 500)\n    window.requestAnimationFrame(() => renderLoop(fn));\n}\n\n\n//# sourceURL=webpack://platformer/./src/main.ts?");

/***/ }),

/***/ "./src/math/geometry.ts":
/*!******************************!*\
  !*** ./src/math/geometry.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sweepSphereToLine: () => (/* binding */ sweepSphereToLine),\n/* harmony export */   sweepSphereToPlane: () => (/* binding */ sweepSphereToPlane),\n/* harmony export */   sweepSphereToPoint: () => (/* binding */ sweepSphereToPoint),\n/* harmony export */   sweepSphereToSegment: () => (/* binding */ sweepSphereToSegment)\n/* harmony export */ });\nfunction sweepSphereToPlane(spherePos, sphereSpeed, sphereRadius, pointOnPlane, planeNormal) {\n    // from WolframAlpha\n    // solve for t: {n, m, o} . ({x, y, z} + {u, v, w} * t) + d = r\n    const x = spherePos.x;\n    const y = spherePos.y;\n    const z = spherePos.z;\n    const u = sphereSpeed.x;\n    const v = sphereSpeed.y;\n    const w = sphereSpeed.z;\n    const r = sphereRadius;\n    const n = planeNormal.x;\n    const m = planeNormal.y;\n    const o = planeNormal.z;\n    const d = -pointOnPlane.dot(planeNormal);\n    const div = (m * v + n * u + o * w);\n    if (div == 0)\n        return Infinity;\n    const t = -(d + m * y + n * x + o * z - r) / div;\n    //if (t < 0 || t > 1)\n    //\treturn Infinity\n    return t;\n}\nfunction sweepSphereToSegment(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector) {\n    const t = sweepSphereToLine(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector.normalized());\n    if (!isFinite(t))\n        return Infinity;\n    const newPos = spherePos.add(sphereSpeed.scale(t));\n    const contact = newPos.add(newPos.directionToLine(lineVector, pointInLine));\n    const lineT = contact.sub(pointInLine).projectT(lineVector);\n    if (lineT < 0 || lineT > 1)\n        return Infinity;\n    return t;\n}\nfunction sweepSphereToLine(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector) {\n    // from WolframAlpha\n    // solve for t: ||{x + u * t, y + v * t, z + w * t} cross {n, m, o}|| = r\n    const x = spherePos.x - pointInLine.x;\n    const y = spherePos.y - pointInLine.y;\n    const z = spherePos.z - pointInLine.z;\n    const u = sphereSpeed.x;\n    const v = sphereSpeed.y;\n    const w = sphereSpeed.z;\n    const n = lineVector.x;\n    const m = lineVector.y;\n    const o = lineVector.z;\n    const r = sphereRadius;\n    const root1 = 2 * m * m * u * x +\n        2 * m * m * w * z -\n        2 * m * n * u * y -\n        2 * m * n * v * x -\n        2 * m * o * v * z -\n        2 * m * o * w * y +\n        2 * n * n * v * y +\n        2 * n * n * w * z -\n        2 * n * o * u * z -\n        2 * n * o * w * x +\n        2 * o * o * u * x +\n        2 * o * o * v * y;\n    const root2 = m * m * u * u +\n        m * m * w * w -\n        2 * m * n * u * v -\n        2 * m * o * v * w +\n        n * n * v * v +\n        n * n * w * w -\n        2 * n * o * u * w +\n        o * o * u * u +\n        o * o * v * v;\n    const root3 = m * m * x * x +\n        m * m * z * z -\n        2 * m * n * x * y -\n        2 * m * o * y * z +\n        n * n * y * y +\n        n * n * z * z -\n        2 * n * o * x * z +\n        o * o * x * x +\n        o * o * y * y -\n        r * r;\n    const rootInner = root1 * root1 - 4 * root2 * root3;\n    if (rootInner < 0)\n        return Infinity;\n    const root = Math.sqrt(rootInner);\n    const div = (2 * root2);\n    if (div == 0)\n        return Infinity;\n    const t1 = (-root - root1) / div;\n    const t2 = (root - root1) / div;\n    const t = Math.min(t1, t2);\n    //if (t < 0 || t > 1)\n    //\treturn Infinity\n    return t;\n}\nfunction sweepSphereToPoint(spherePos, sphereSpeed, sphereRadius, point) {\n    // from WolframAlpha\n    // solve for t: ||{x, y, z} + {u, v, w} * t|| = r\n    const x = spherePos.x - point.x;\n    const y = spherePos.y - point.y;\n    const z = spherePos.z - point.z;\n    const u = sphereSpeed.x;\n    const v = sphereSpeed.y;\n    const w = sphereSpeed.z;\n    const r = sphereRadius;\n    const div = 2 * (u * u + v * v + w * w);\n    if (div == 0)\n        return Infinity;\n    const root = Math.pow(2 * u * x + 2 * v * y + 2 * w * z, 2) -\n        4 * (u * u + v * v + w * w) *\n            (-(r * r) + x * x + y * y + z * z);\n    if (root < 0)\n        return Infinity;\n    const t1 = 1 / div * (-Math.sqrt(root) - 2 * u * x - 2 * v * y - 2 * w * z);\n    const t2 = 1 / div * (Math.sqrt(root) - 2 * u * x - 2 * v * y - 2 * w * z);\n    const t = Math.min(t1, t2);\n    //if (t < 0 || t > 1)\n    //\treturn Infinity\n    return t;\n}\n/*export function linePointMinimumVec(origin, direction, point)\n{\n    let pointFromOrigin = point.sub(origin)\n    let pointOverDirection = pointFromOrigin.project(direction)\n    \n    return pointFromOrigin.sub(pointOverDirection)\n}\n\n\nexport function linePointDistance(origin, direction, point)\n{\n    return Geometry.linePointMinimumVec(origin, direction, point).magn()\n}\n\n\nexport function lineLineDistance(origin1, direction1, origin2, direction2)\n{\n    let cross = direction1.cross(direction2)\n    let crossMagn = cross.magn()\n    \n    if (crossMagn < 0.001)\n        return Infinity // wrong but works\n    \n    return Math.abs(cross.scale(1 / crossMagn).dot(origin2.sub(origin1)))\n}\n\n\nexport function lineZPlaneIntersection(origin, direction, planeZ)\n{\n    return origin.add(direction.scale((planeZ - origin.z) / direction.z))\n}*/ \n\n\n//# sourceURL=webpack://platformer/./src/math/geometry.ts?");

/***/ }),

/***/ "./src/math/mat4.ts":
/*!**************************!*\
  !*** ./src/math/mat4.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mat4)\n/* harmony export */ });\n/* harmony import */ var _vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vec3 */ \"./src/math/vec3.ts\");\n\nclass Mat4 {\n    m;\n    constructor(cells) {\n        this.m = new Float32Array(cells);\n    }\n    static identity() {\n        return identity;\n    }\n    static translation(x, y, z) {\n        return new Mat4([\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            x, y, z, 1\n        ]);\n    }\n    static scale(x, y, z) {\n        return new Mat4([\n            x, 0, 0, 0,\n            0, y, 0, 0,\n            0, 0, z, 0,\n            0, 0, 0, 1\n        ]);\n    }\n    static rotation(vec, radians) {\n        const x = vec.x;\n        const y = vec.y;\n        const z = vec.z;\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        const t = 1 - c;\n        return new Mat4([\n            t * x * x + c, t * x * y - z * s, t * x * z + y * s, 0,\n            t * x * y + z * s, t * y * y + c, t * y * z - x * s, 0,\n            t * x * z - y * s, t * y * z + x * s, t * z * z + c, 0,\n            0, 0, 0, 1\n        ]);\n    }\n    static rotationFromTo(fromVec, toVec) {\n        const axis = fromVec.cross(toVec).normalized();\n        const angle = Math.acos(fromVec.dot(toVec));\n        return Mat4.rotation(axis, -angle);\n    }\n    static basisRotation(i1, j1, k1, i2, j2, k2) {\n        const basis1 = new Mat4([\n            i1.x, j1.x, k1.x, 0,\n            i1.y, j1.y, k1.y, 0,\n            i1.z, j1.z, k1.z, 0,\n            0, 0, 0, 1,\n        ]);\n        const basis2 = new Mat4([\n            i2.x, j2.x, k2.x, 0,\n            i2.y, j2.y, k2.y, 0,\n            i2.z, j2.z, k2.z, 0,\n            0, 0, 0, 1,\n        ]);\n        return basis1.mul(basis2.transpose());\n    }\n    static ortho(left, right, top, bottom, near, far) {\n        return new Mat4([\n            2 / (right - left), 0, 0, 0,\n            0, 2 / (top - bottom), 0, 0,\n            0, 0, -2 / (far - near), 0,\n            -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1\n        ]);\n    }\n    static frustum(left, right, top, bottom, near, far) {\n        return new Mat4([\n            2 * near / (right - left), 0, 0, 0,\n            0, 2 * near / (top - bottom), 0, 0,\n            (right + left) / (right - left), (top + bottom) / (top - bottom), -(far + near) / (far - near), -1,\n            0, 0, -(2 * far * near) / (far - near), 0\n        ]);\n    }\n    static perspective(fovyRadians, aspectWidthByHeight, near, far) {\n        const h = Math.tan(fovyRadians) * near;\n        const w = h * aspectWidthByHeight;\n        return Mat4.frustum(-w, w, -h, h, near, far);\n    }\n    static lookat(eye, target, up) {\n        const zaxis = eye.sub(target).normalized();\n        const xaxis = zaxis.cross(up).normalized();\n        const yaxis = zaxis.cross(xaxis);\n        return new Mat4([\n            xaxis.x, yaxis.x, zaxis.x, 0,\n            xaxis.y, yaxis.y, zaxis.y, 0,\n            xaxis.z, yaxis.z, zaxis.z, 0,\n            -xaxis.dot(eye), -yaxis.dot(eye), -zaxis.dot(eye), 1\n        ]);\n    }\n    transpose() {\n        return new Mat4([\n            this.m[0 * 4 + 0], this.m[1 * 4 + 0], this.m[2 * 4 + 0], this.m[3 * 4 + 0],\n            this.m[0 * 4 + 1], this.m[1 * 4 + 1], this.m[2 * 4 + 1], this.m[3 * 4 + 1],\n            this.m[0 * 4 + 2], this.m[1 * 4 + 2], this.m[2 * 4 + 2], this.m[3 * 4 + 2],\n            this.m[0 * 4 + 3], this.m[1 * 4 + 3], this.m[2 * 4 + 3], this.m[3 * 4 + 3]\n        ]);\n    }\n    mul(other) {\n        if (this === identity)\n            return other;\n        if (other === identity)\n            return this;\n        const a00 = +this.m[0 * 4 + 0];\n        const a01 = +this.m[0 * 4 + 1];\n        const a02 = +this.m[0 * 4 + 2];\n        const a03 = +this.m[0 * 4 + 3];\n        const a10 = +this.m[1 * 4 + 0];\n        const a11 = +this.m[1 * 4 + 1];\n        const a12 = +this.m[1 * 4 + 2];\n        const a13 = +this.m[1 * 4 + 3];\n        const a20 = +this.m[2 * 4 + 0];\n        const a21 = +this.m[2 * 4 + 1];\n        const a22 = +this.m[2 * 4 + 2];\n        const a23 = +this.m[2 * 4 + 3];\n        const a30 = +this.m[3 * 4 + 0];\n        const a31 = +this.m[3 * 4 + 1];\n        const a32 = +this.m[3 * 4 + 2];\n        const a33 = +this.m[3 * 4 + 3];\n        const b00 = +other.m[0 * 4 + 0];\n        const b01 = +other.m[0 * 4 + 1];\n        const b02 = +other.m[0 * 4 + 2];\n        const b03 = +other.m[0 * 4 + 3];\n        const b10 = +other.m[1 * 4 + 0];\n        const b11 = +other.m[1 * 4 + 1];\n        const b12 = +other.m[1 * 4 + 2];\n        const b13 = +other.m[1 * 4 + 3];\n        const b20 = +other.m[2 * 4 + 0];\n        const b21 = +other.m[2 * 4 + 1];\n        const b22 = +other.m[2 * 4 + 2];\n        const b23 = +other.m[2 * 4 + 3];\n        const b30 = +other.m[3 * 4 + 0];\n        const b31 = +other.m[3 * 4 + 1];\n        const b32 = +other.m[3 * 4 + 2];\n        const b33 = +other.m[3 * 4 + 3];\n        const m00 = (a00 * b00) + (a01 * b10) + (a02 * b20) + (a03 * b30);\n        const m01 = (a00 * b01) + (a01 * b11) + (a02 * b21) + (a03 * b31);\n        const m02 = (a00 * b02) + (a01 * b12) + (a02 * b22) + (a03 * b32);\n        const m03 = (a00 * b03) + (a01 * b13) + (a02 * b23) + (a03 * b33);\n        const m10 = (a10 * b00) + (a11 * b10) + (a12 * b20) + (a13 * b30);\n        const m11 = (a10 * b01) + (a11 * b11) + (a12 * b21) + (a13 * b31);\n        const m12 = (a10 * b02) + (a11 * b12) + (a12 * b22) + (a13 * b32);\n        const m13 = (a10 * b03) + (a11 * b13) + (a12 * b23) + (a13 * b33);\n        const m20 = (a20 * b00) + (a21 * b10) + (a22 * b20) + (a23 * b30);\n        const m21 = (a20 * b01) + (a21 * b11) + (a22 * b21) + (a23 * b31);\n        const m22 = (a20 * b02) + (a21 * b12) + (a22 * b22) + (a23 * b32);\n        const m23 = (a20 * b03) + (a21 * b13) + (a22 * b23) + (a23 * b33);\n        const m30 = (a30 * b00) + (a31 * b10) + (a32 * b20) + (a33 * b30);\n        const m31 = (a30 * b01) + (a31 * b11) + (a32 * b21) + (a33 * b31);\n        const m32 = (a30 * b02) + (a31 * b12) + (a32 * b22) + (a33 * b32);\n        const m33 = (a30 * b03) + (a31 * b13) + (a32 * b23) + (a33 * b33);\n        return new Mat4([\n            m00, m01, m02, m03,\n            m10, m11, m12, m13,\n            m20, m21, m22, m23,\n            m30, m31, m32, m33\n        ]);\n        /*let result =\n        [\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0]\n        ]\n\n        for (let j = 0; j < 4; j++)\n        {\n            for (let i = 0; i < 4; i++)\n            {\n                let acc = 0\n                for (let k = 0; k < 4; k++)\n                    acc += this.m[j * 4 + k] * other.m[k * 4 + i]\n                \n                result[j][i] = acc\n            }\n        }\n        \n        return new Mat4(result)*/\n    }\n    mulVec4(v) {\n        let result = [0, 0, 0, 0];\n        for (let i = 0; i < 4; i++) {\n            let acc = 0;\n            for (let k = 0; k < 4; k++)\n                acc += this.m[i * 4 + k] * v[k];\n            result[i] = acc;\n        }\n        return result;\n    }\n    mulPoint(vec) {\n        const v = [vec.x, vec.y, vec.z, 1];\n        let result = [0, 0, 0, 0];\n        for (let i = 0; i < 4; i++) {\n            let acc = 0;\n            for (let k = 0; k < 4; k++)\n                acc += this.m[i * 4 + k] * v[k];\n            result[i] = acc;\n        }\n        return new _vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"](result[0], result[1], result[2]);\n    }\n    mulDirection(vec) {\n        const v = [vec.x, vec.y, vec.z, 0];\n        let result = [0, 0, 0, 0];\n        for (let i = 0; i < 4; i++) {\n            let acc = 0;\n            for (let k = 0; k < 4; k++)\n                acc += this.m[i * 4 + k] * v[k];\n            result[i] = acc;\n        }\n        return new _vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"](result[0], result[1], result[2]);\n    }\n    asFloat32Array() {\n        return this.m; /*new Float32Array([\n            this.m[0 * 4 + 0], this.m[0 * 4 + 1], this.m[0 * 4 + 2], this.m[0 * 4 + 3],\n            this.m[1 * 4 + 0], this.m[1 * 4 + 1], this.m[1 * 4 + 2], this.m[1 * 4 + 3],\n            this.m[2 * 4 + 0], this.m[2 * 4 + 1], this.m[2 * 4 + 2], this.m[2 * 4 + 3],\n            this.m[3 * 4 + 0], this.m[3 * 4 + 1], this.m[3 * 4 + 2], this.m[3 * 4 + 3]])*/\n    }\n    invert() {\n        // From https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix\n        const a2323 = this.m[2 * 4 + 2] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 2];\n        const a1323 = this.m[2 * 4 + 1] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 1];\n        const a1223 = this.m[2 * 4 + 1] * this.m[3 * 4 + 2] - this.m[2 * 4 + 2] * this.m[3 * 4 + 1];\n        const a0323 = this.m[2 * 4 + 0] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 0];\n        const a0223 = this.m[2 * 4 + 0] * this.m[3 * 4 + 2] - this.m[2 * 4 + 2] * this.m[3 * 4 + 0];\n        const a0123 = this.m[2 * 4 + 0] * this.m[3 * 4 + 1] - this.m[2 * 4 + 1] * this.m[3 * 4 + 0];\n        const a2313 = this.m[1 * 4 + 2] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 2];\n        const a1313 = this.m[1 * 4 + 1] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 1];\n        const a1213 = this.m[1 * 4 + 1] * this.m[3 * 4 + 2] - this.m[1 * 4 + 2] * this.m[3 * 4 + 1];\n        const a2312 = this.m[1 * 4 + 2] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 2];\n        const a1312 = this.m[1 * 4 + 1] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 1];\n        const a1212 = this.m[1 * 4 + 1] * this.m[2 * 4 + 2] - this.m[1 * 4 + 2] * this.m[2 * 4 + 1];\n        const a0313 = this.m[1 * 4 + 0] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 0];\n        const a0213 = this.m[1 * 4 + 0] * this.m[3 * 4 + 2] - this.m[1 * 4 + 2] * this.m[3 * 4 + 0];\n        const a0312 = this.m[1 * 4 + 0] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 0];\n        const a0212 = this.m[1 * 4 + 0] * this.m[2 * 4 + 2] - this.m[1 * 4 + 2] * this.m[2 * 4 + 0];\n        const a0113 = this.m[1 * 4 + 0] * this.m[3 * 4 + 1] - this.m[1 * 4 + 1] * this.m[3 * 4 + 0];\n        const a0112 = this.m[1 * 4 + 0] * this.m[2 * 4 + 1] - this.m[1 * 4 + 1] * this.m[2 * 4 + 0];\n        const det = 1 / (this.m[0 * 4 + 0] * (this.m[1 * 4 + 1] * a2323 - this.m[1 * 4 + 2] * a1323 + this.m[1 * 4 + 3] * a1223) -\n            this.m[0 * 4 + 1] * (this.m[1 * 4 + 0] * a2323 - this.m[1 * 4 + 2] * a0323 + this.m[1 * 4 + 3] * a0223) +\n            this.m[0 * 4 + 2] * (this.m[1 * 4 + 0] * a1323 - this.m[1 * 4 + 1] * a0323 + this.m[1 * 4 + 3] * a0123) -\n            this.m[0 * 4 + 3] * (this.m[1 * 4 + 0] * a1223 - this.m[1 * 4 + 1] * a0223 + this.m[1 * 4 + 2] * a0123));\n        return new Mat4([\n            det * (this.m[1 * 4 + 1] * a2323 - this.m[1 * 4 + 2] * a1323 + this.m[1 * 4 + 3] * a1223),\n            det * -(this.m[0 * 4 + 1] * a2323 - this.m[0 * 4 + 2] * a1323 + this.m[0 * 4 + 3] * a1223),\n            det * (this.m[0 * 4 + 1] * a2313 - this.m[0 * 4 + 2] * a1313 + this.m[0 * 4 + 3] * a1213),\n            det * -(this.m[0 * 4 + 1] * a2312 - this.m[0 * 4 + 2] * a1312 + this.m[0 * 4 + 3] * a1212),\n            det * -(this.m[1 * 4 + 0] * a2323 - this.m[1 * 4 + 2] * a0323 + this.m[1 * 4 + 3] * a0223),\n            det * (this.m[0 * 4 + 0] * a2323 - this.m[0 * 4 + 2] * a0323 + this.m[0 * 4 + 3] * a0223),\n            det * -(this.m[0 * 4 + 0] * a2313 - this.m[0 * 4 + 2] * a0313 + this.m[0 * 4 + 3] * a0213),\n            det * (this.m[0 * 4 + 0] * a2312 - this.m[0 * 4 + 2] * a0312 + this.m[0 * 4 + 3] * a0212),\n            det * (this.m[1 * 4 + 0] * a1323 - this.m[1 * 4 + 1] * a0323 + this.m[1 * 4 + 3] * a0123),\n            det * -(this.m[0 * 4 + 0] * a1323 - this.m[0 * 4 + 1] * a0323 + this.m[0 * 4 + 3] * a0123),\n            det * (this.m[0 * 4 + 0] * a1313 - this.m[0 * 4 + 1] * a0313 + this.m[0 * 4 + 3] * a0113),\n            det * -(this.m[0 * 4 + 0] * a1312 - this.m[0 * 4 + 1] * a0312 + this.m[0 * 4 + 3] * a0112),\n            det * -(this.m[1 * 4 + 0] * a1223 - this.m[1 * 4 + 1] * a0223 + this.m[1 * 4 + 2] * a0123),\n            det * (this.m[0 * 4 + 0] * a1223 - this.m[0 * 4 + 1] * a0223 + this.m[0 * 4 + 2] * a0123),\n            det * -(this.m[0 * 4 + 0] * a1213 - this.m[0 * 4 + 1] * a0213 + this.m[0 * 4 + 2] * a0113),\n            det * (this.m[0 * 4 + 0] * a1212 - this.m[0 * 4 + 1] * a0212 + this.m[0 * 4 + 2] * a0112),\n        ]).transpose();\n    }\n}\nconst identity = new Mat4([\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n]);\n\n\n//# sourceURL=webpack://platformer/./src/math/mat4.ts?");

/***/ }),

/***/ "./src/math/vec3.ts":
/*!**************************!*\
  !*** ./src/math/vec3.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vec3)\n/* harmony export */ });\nclass Vec3 {\n    x;\n    y;\n    z;\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    clone() {\n        return new Vec3(this.x, this.y, this.z);\n    }\n    magn() {\n        return Math.sqrt(this.dot(this));\n    }\n    magnSqr() {\n        return this.dot(this);\n    }\n    withZ(z) {\n        return new Vec3(this.x, this.y, z);\n    }\n    withMagn(magn) {\n        return this.normalized().scale(magn);\n    }\n    withAddedMagn(t) {\n        return this.normalized().scale(this.magn() + t);\n    }\n    normalized() {\n        const magn = this.magn();\n        if (magn == 0)\n            return this;\n        return new Vec3(this.x / magn, this.y / magn, this.z / magn);\n    }\n    add(other) {\n        return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);\n    }\n    sub(other) {\n        return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);\n    }\n    neg() {\n        return new Vec3(-this.x, -this.y, -this.z);\n    }\n    scale(f) {\n        return new Vec3(this.x * f, this.y * f, this.z * f);\n    }\n    mul(other) {\n        return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);\n    }\n    dot(other) {\n        return (this.x * other.x + this.y * other.y + this.z * other.z);\n    }\n    cross(other) {\n        return new Vec3(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);\n    }\n    lerp(other, amount) {\n        return new Vec3(this.x + (other.x - this.x) * amount, this.y + (other.y - this.y) * amount, this.z + (other.z - this.z) * amount);\n    }\n    min(other) {\n        if (other == null)\n            return this;\n        return new Vec3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));\n    }\n    max(other) {\n        if (other == null)\n            return this;\n        return new Vec3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));\n    }\n    projectT(other) {\n        return this.dot(other) / other.dot(other);\n    }\n    project(other) {\n        return other.scale(this.dot(other) / other.dot(other));\n    }\n    projectOnPlane(planeNormal) {\n        return this.sub(this.project(planeNormal));\n    }\n    directionToLine(lineVector, pointOnLine) {\n        const vec = this.sub(pointOnLine);\n        const proj = vec.sub(vec.project(lineVector));\n        return proj;\n    }\n    directionToPlane(planeNormal, pointOnPlane) {\n        const p = this.sub(pointOnPlane);\n        return p.sub(p.project(planeNormal)).add(pointOnPlane).sub(this);\n    }\n    signedSqrDistanceToPlane(planeNormal, pointOnPlane) {\n        const distPlane = this.directionToPlane(planeNormal, pointOnPlane);\n        const dotPlane = this.sub(pointOnPlane).dot(planeNormal);\n        return distPlane.magnSqr() * Math.sign(dotPlane);\n    }\n    asArray() {\n        return [this.x, this.y, this.z];\n    }\n    isFinite() {\n        return isFinite(this.x) && isFinite(this.y) && isFinite(this.z);\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/math/vec3.ts?");

/***/ }),

/***/ "./src/objects/_object.ts":
/*!********************************!*\
  !*** ./src/objects/_object.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Object: () => (/* binding */ Object)\n/* harmony export */ });\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\nclass Object {\n    director;\n    position = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0);\n    scale = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1, 1, 1);\n    init() {\n    }\n    process() {\n    }\n    render() {\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/_object.ts?");

/***/ }),

/***/ "./src/objects/camera.ts":
/*!*******************************!*\
  !*** ./src/objects/camera.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _stage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stage */ \"./src/objects/stage.ts\");\n/* harmony import */ var _kart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./kart */ \"./src/objects/kart.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./player */ \"./src/objects/player.ts\");\n/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./test */ \"./src/objects/test.ts\");\n\n\n\n\n\n\n\n\nclass Camera extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    model;\n    lookAt = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    up = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, -1);\n    init() {\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        builder.addCube(-1, -1, -1, 1, 1, 1);\n        builder.calculateNormals();\n        this.model = builder.makeModel(this.director.gl);\n    }\n    setMatrices() {\n        this.director.scene.setProjection(_math_mat4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].perspective(60, this.director.canvasW / this.director.canvasH, 0.1, 10000));\n        this.director.scene.setView(_math_mat4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].lookat(this.position, this.lookAt, this.up));\n    }\n    process() {\n        let target = this.director.objectFind(_kart__WEBPACK_IMPORTED_MODULE_5__.Kart);\n        if (!target)\n            target = this.director.objectFind(_player__WEBPACK_IMPORTED_MODULE_6__.Player);\n        if (!target)\n            target = this.director.objectFind(_test__WEBPACK_IMPORTED_MODULE_7__.Test);\n        if (!target)\n            return;\n        if (target instanceof _kart__WEBPACK_IMPORTED_MODULE_5__.Kart) {\n            this.lookAt = target.center.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, -1));\n            this.position = target.center\n                .sub(target.forward.withZ(0).normalized().scale(5))\n                .add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, -1.5));\n            const stage = this.director.objectFind(_stage__WEBPACK_IMPORTED_MODULE_4__.Stage);\n            if (stage) {\n                const collision = stage.collision.collide(this.position.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, -10)), this.position, 0.1);\n                if (collision.collided)\n                    this.position = collision.position;\n            }\n            /*this.position = target.center\n                .sub(target.forward.normalized().scale(5))\n                .add(target.up.normalized().scale(1.5))*/\n        }\n        else {\n            this.lookAt = target.position;\n            const speed = 0.5;\n            const goalDistance = 5;\n            const dirToLookat = this.lookAt.sub(this.position).normalized().withZ(0).scale(goalDistance);\n            const goalPos = this.lookAt.sub(dirToLookat).add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0.5 - goalDistance * 0.45));\n            this.position = goalPos;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/camera.ts?");

/***/ }),

/***/ "./src/objects/kart.ts":
/*!*****************************!*\
  !*** ./src/objects/kart.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kart: () => (/* binding */ Kart)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _sphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere */ \"./src/objects/sphere.ts\");\n/* harmony import */ var _stage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stage */ \"./src/objects/stage.ts\");\n\n\n\n\n\n\nfunction approach(from, to, step) {\n    if (from < to)\n        return Math.min(from + step, to);\n    else\n        return Math.max(from - step, to);\n}\nclass Kart extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    bodies;\n    joints;\n    center;\n    centerPrev;\n    nose;\n    forward;\n    up;\n    right;\n    speed;\n    engineSpeed = 0;\n    steerSpeed = 0;\n    init() {\n        this.bodies =\n            [\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\n            ];\n        for (const body of this.bodies)\n            body.init(this.director);\n        this.joints = [];\n        this.reset();\n    }\n    reset() {\n        const bodyForwardLen = 0.25;\n        const bodySideLen = 0.125;\n        const chassiHeight = -0.15;\n        const wheelRadius = 0.15;\n        const pos = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](50, 50, -15);\n        this.bodies[0].id = 0;\n        this.bodies[1].id = 1;\n        this.bodies[2].id = 2;\n        this.bodies[3].id = 3;\n        this.bodies[4].id = 4;\n        this.bodies[5].id = 5;\n        this.bodies[0].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-bodyForwardLen, -bodySideLen, 0));\n        this.bodies[1].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-bodyForwardLen, bodySideLen, 0));\n        this.bodies[2].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](bodyForwardLen, bodySideLen, 0));\n        this.bodies[3].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](bodyForwardLen, -bodySideLen, 0));\n        this.bodies[4].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0));\n        this.bodies[5].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, chassiHeight));\n        this.bodies[0].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[1].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[2].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[3].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[4].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[5].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.bodies[0].radius = wheelRadius;\n        this.bodies[1].radius = wheelRadius;\n        this.bodies[2].radius = wheelRadius;\n        this.bodies[3].radius = wheelRadius;\n        this.bodies[4].radius = wheelRadius;\n        this.bodies[5].radius = wheelRadius;\n        const addJoint = (body1, body2, tensionK, frictionK) => {\n            this.joints.push({\n                body1,\n                body2,\n                length: body1.pos.sub(body2.pos).magn(),\n                tensionK,\n                frictionK,\n            });\n        };\n        this.joints = [];\n        const tensionK = 0.5;\n        const frictionK = 0.05;\n        // Outer Edges\n        addJoint(this.bodies[0], this.bodies[1], tensionK, frictionK);\n        addJoint(this.bodies[2], this.bodies[3], tensionK, frictionK);\n        addJoint(this.bodies[0], this.bodies[3], tensionK, frictionK);\n        addJoint(this.bodies[1], this.bodies[2], tensionK, frictionK);\n        // Chassi\n        addJoint(this.bodies[0], this.bodies[4], tensionK, frictionK);\n        addJoint(this.bodies[1], this.bodies[4], tensionK, frictionK);\n        addJoint(this.bodies[2], this.bodies[4], tensionK, frictionK);\n        addJoint(this.bodies[3], this.bodies[4], tensionK, frictionK);\n        addJoint(this.bodies[0], this.bodies[5], tensionK, frictionK);\n        addJoint(this.bodies[1], this.bodies[5], tensionK, frictionK);\n        addJoint(this.bodies[2], this.bodies[5], tensionK, frictionK);\n        addJoint(this.bodies[3], this.bodies[5], tensionK, frictionK);\n        addJoint(this.bodies[4], this.bodies[5], tensionK, frictionK);\n    }\n    process() {\n        this.handleVectors();\n        this.handleMovement();\n        this.handleJoints();\n        const stage = this.director.objectFind(_stage__WEBPACK_IMPORTED_MODULE_5__.Stage);\n        if (!stage)\n            return;\n        for (const body of this.bodies) {\n            body.processGravity();\n            body.processCollision(stage.collision);\n        }\n    }\n    handleVectors() {\n        this.centerPrev = this.center ?? new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        this.center = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n        for (const body of this.bodies)\n            this.center = this.center.add(body.pos);\n        this.center = this.center.scale(1 / this.bodies.length);\n        this.position = this.center;\n        this.speed = this.center.sub(this.centerPrev);\n        this.nose = this.bodies[0].pos.add(this.bodies[1].pos).scale(1 / 2);\n        this.forward = this.nose.sub(this.center).normalized();\n        this.up = this.forward.cross(this.bodies[0].pos.sub(this.bodies[1].pos)).normalized();\n        if (this.up.z > 0)\n            this.up = this.up.neg();\n        this.right = this.up.cross(this.forward);\n    }\n    handleMovement() {\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\n        if (!camera)\n            return;\n        const accel = 0.015;\n        const maxSpeed = 0.22;\n        const steerAccel = 0.0025;\n        const steerDecel = 0.005;\n        const steerMaxSpeed = 0.02;\n        if (this.director.keysHeld.has(\"arrowup\") ||\n            this.director.keysHeld.has(\"w\") ||\n            this.director.keysHeld.has(\" \"))\n            this.engineSpeed = approach(this.engineSpeed, 1, 1);\n        else if (this.director.keysHeld.has(\"arrowdown\") ||\n            this.director.keysHeld.has(\"s\") ||\n            this.director.keysHeld.has(\"x\"))\n            this.engineSpeed = approach(this.engineSpeed, -1, 1);\n        else\n            this.engineSpeed = 0; //approach(this.engineSpeed, 0, decel)\n        if (this.director.keysHeld.has(\"arrowleft\") ||\n            this.director.keysHeld.has(\"a\"))\n            this.steerSpeed = approach(this.steerSpeed, -steerMaxSpeed, steerAccel);\n        else if (this.director.keysHeld.has(\"arrowright\") ||\n            this.director.keysHeld.has(\"d\"))\n            this.steerSpeed = approach(this.steerSpeed, steerMaxSpeed, steerAccel);\n        else\n            this.steerSpeed = approach(this.steerSpeed, 0, steerDecel);\n        for (const body of this.bodies) {\n            if (!body.touchingGround)\n                continue;\n            const targetForce = this.forward.scale(this.engineSpeed * maxSpeed);\n            const accelForce = targetForce.sub(body.speed).scale(accel);\n            body.speed = body.speed.add(accelForce);\n            const sideFriction = body.speed.project(this.right);\n            body.speed = body.speed.sub(sideFriction.scale(0.25));\n        }\n        const steerMatrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rotation(this.up, this.steerSpeed);\n        for (const body of this.bodies) {\n            const fromCenter = body.pos.sub(this.center);\n            const rotated = steerMatrix.mulPoint(fromCenter);\n            body.instantSpeed = body.instantSpeed.add(rotated.sub(fromCenter));\n        }\n    }\n    handleJoints() {\n        for (const joint of this.joints) {\n            const dir = joint.body1.pos.sub(joint.body2.pos);\n            const dirN = dir.normalized();\n            const dist = dir.magn();\n            const tensionForce = dirN.scale((dist - joint.length) * joint.tensionK);\n            joint.body1.speed = joint.body1.speed.sub(tensionForce);\n            joint.body2.speed = joint.body2.speed.add(tensionForce);\n            const frictionForce = joint.body1.speed.sub(joint.body2.speed).scale(joint.frictionK);\n            joint.body1.speed = joint.body1.speed.sub(frictionForce);\n            joint.body2.speed = joint.body2.speed.add(frictionForce);\n        }\n    }\n    render() {\n        for (const body of this.bodies)\n            body.render();\n        for (const joint of this.joints) {\n            this.director.scene.drawArrow(joint.body1.pos, joint.body2.pos, 0.025, [1, 1, 1, 1]);\n        }\n        /*this.director.scene.drawArrow(\n            this.center,\n            this.center.add(this.forward.withMagn(0.5)),\n            0.025,\n            [1, 0, 0, 1])\n            \n        this.director.scene.drawArrow(\n            this.center,\n            this.center.add(this.right.withMagn(0.5)),\n            0.025,\n            [0, 0, 1, 1])*/\n        this.director.scene.drawArrow(this.center, this.center.add(this.up.withMagn(100)), 0.025, [0, 1, 0, 1]);\n        this.director.scene.drawArrow(this.center, this.center.add(this.bodies[0].speed.scale(100)), 0.025, [1, 1, 0, 1]);\n        this.director.scene.drawArrow(this.center, this.center.add(this.bodies[0].speed.project(this.right).scale(100)), 0.025, [1, 0, 1, 1]);\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/kart.ts?");

/***/ }),

/***/ "./src/objects/player.ts":
/*!*******************************!*\
  !*** ./src/objects/player.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stage1 */ \"./src/objects/stage1.ts\");\n\n\n\n\n\nclass Player extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    model;\n    posPrev = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    radius = 0.15;\n    collisionPos = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    init() {\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        builder.addSphere(-this.radius, -this.radius, -this.radius, this.radius, this.radius, this.radius);\n        builder.calculateNormals();\n        this.model = builder.makeModel(this.director.gl);\n        this.posPrev = this.position;\n    }\n    process() {\n        this.handleMovement();\n        this.handleJump();\n        this.handleCollision();\n        this.posPrev = this.position;\n    }\n    handleMovement() {\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\n        if (!camera)\n            return;\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](forward.y, -forward.x, 0);\n        const accel = 0.005;\n        const decel = 0.015;\n        const maxSpeed = 0.05;\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n        if (this.director.keysHeld.has(\"arrowup\") ||\n            this.director.keysHeld.has(\"w\"))\n            moveVec.y += 1;\n        if (this.director.keysHeld.has(\"arrowdown\") ||\n            this.director.keysHeld.has(\"s\"))\n            moveVec.y -= 1;\n        if (this.director.keysHeld.has(\"arrowleft\") ||\n            this.director.keysHeld.has(\"a\"))\n            moveVec.x -= 1;\n        if (this.director.keysHeld.has(\"arrowright\") ||\n            this.director.keysHeld.has(\"d\"))\n            moveVec.x += 1;\n        moveVec = moveVec.normalized().scale(accel);\n        let groundSpeed = this.speed.withZ(0);\n        groundSpeed = groundSpeed\n            .add(forward.scale(moveVec.y))\n            .add(sideways.scale(moveVec.x));\n        const speedMagn = groundSpeed.withZ(0).magn();\n        if (speedMagn > maxSpeed)\n            groundSpeed = groundSpeed.withZ(0).normalized().scale(maxSpeed);\n        if (moveVec.magn() == 0) {\n            if (speedMagn > decel)\n                groundSpeed = groundSpeed.sub(groundSpeed.normalized().scale(decel));\n            else\n                groundSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, groundSpeed.z);\n        }\n        this.speed = this.speed.sub(this.speed.withZ(0)).add(groundSpeed);\n    }\n    handleJump() {\n        this.speed = this.speed.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0.01));\n        if (this.director.keysDown.has(\" \")) {\n            this.speed = this.speed.withZ(-0.15);\n        }\n    }\n    handleCollision() {\n        const stage = this.director.objectFind(_stage1__WEBPACK_IMPORTED_MODULE_4__.Stage1);\n        if (!stage)\n            return;\n        this.collisionPos = this.position;\n        const solvedGravity = stage.collision.repel(this.position, this.position.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, this.speed.z)), this.radius);\n        this.position = solvedGravity.position;\n        if (this.position.z <= this.posPrev.z &&\n            this.speed.z > 0)\n            this.speed = this.speed.withZ(0);\n        const solved = stage.collision.repelAndSlide(this.position, this.position.add(this.speed.withZ(0)), this.radius);\n        this.position = solved.position;\n    }\n    render() {\n        this.director.scene.pushTranslationScale(this.position, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, 1, 1]);\n        this.director.scene.popTranslationScale();\n        /*this.director.scene.pushTranslationScale(this.collisionPos, this.scale)\n        this.director.scene.drawModel(\n            this.model,\n            this.director.scene.materialColor,\n            [1, 0, 0, 1])\n        this.director.scene.popTranslationScale()*/\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/player.ts?");

/***/ }),

/***/ "./src/objects/sphere.ts":
/*!*******************************!*\
  !*** ./src/objects/sphere.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sphere: () => (/* binding */ Sphere)\n/* harmony export */ });\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\n\nclass Sphere {\n    director;\n    model;\n    id = 0;\n    pos = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n    posPrev = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n    speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n    instantSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n    radius = 0.15;\n    touchingGround = false;\n    init(director) {\n        this.director = director;\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        builder.addSphere(-1, -1, -1, 1, 1, 1);\n        builder.calculateNormals();\n        this.model = builder.makeModel(this.director.gl);\n    }\n    processGravity() {\n        this.speed = this.speed.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0.0025));\n    }\n    processCollision(collision) {\n        this.touchingGround = false;\n        this.posPrev = this.pos;\n        const posPlusGravity = this.pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, this.speed.z));\n        const solvedGravity = collision.repel(this.pos, posPlusGravity, this.radius);\n        this.pos = solvedGravity.position;\n        const solved = collision.repelAndSlide(this.pos, this.pos.add(this.speed.withZ(0)), this.radius);\n        this.pos = solved.position;\n        this.speed = this.pos.sub(this.posPrev);\n        if (this.instantSpeed.magn() != 0) {\n            const solvedInstant = collision.repel(this.pos, this.pos.add(this.instantSpeed), this.radius);\n            this.pos = solvedInstant.position;\n        }\n        this.instantSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n        const groundCheckDist = 0.1;\n        const solvedGroundTest = collision.repel(this.pos, this.pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, this.radius + groundCheckDist)), this.radius);\n        if (solvedGroundTest.position.z <= this.pos.z + groundCheckDist)\n            this.touchingGround = true;\n        if (false) //(this.id == 0)\n         {}\n    }\n    render() {\n        this.director.scene.pushTranslationScale(this.pos, new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.radius, this.radius, this.radius).scale(0.5));\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, this.touchingGround ? 1 : 0, 1]);\n        this.director.scene.popTranslationScale();\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/sphere.ts?");

/***/ }),

/***/ "./src/objects/stage.ts":
/*!******************************!*\
  !*** ./src/objects/stage.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stage: () => (/* binding */ Stage)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n\nclass Stage extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    model;\n    collision;\n    init() {\n    }\n    setModel(gl, builder) {\n        this.model = builder.makeModel(gl);\n        this.collision = builder.makeCollision();\n        console.log(this.collision.triangles);\n    }\n    render() {\n        this.director.scene.pushTranslationScale(this.position, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [0.1, 0.75, 1, 1]);\n        this.director.scene.popTranslationScale();\n        return;\n        for (const tri of this.collision.triangles) {\n            this.director.scene.drawArrow(tri.centroid, tri.centroid.add(tri.normal.scale(0.1)), 0.025, [1, 0, 0, 1]);\n            this.director.scene.drawArrow(tri.v1, tri.v1.add(tri.normal.scale(0.1)), 0.025, [0, 0, 1, 1]);\n            this.director.scene.drawArrow(tri.v2, tri.v2.add(tri.normal.scale(0.1)), 0.025, [0, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v1to2Center, tri.v1to2Center.add(tri.v1to2Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v2to3Center, tri.v2to3Center.add(tri.v2to3Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v3to1Center, tri.v3to1Center.add(tri.v3to1Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/stage.ts?");

/***/ }),

/***/ "./src/objects/stage1.ts":
/*!*******************************!*\
  !*** ./src/objects/stage1.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stage1: () => (/* binding */ Stage1)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\n\n\nclass Stage1 extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    model;\n    collision;\n    init() {\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        builder.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-10, -10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](10, -10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](10, 10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-10, 10, 0));\n        builder.addCube(-5, -5, -1, -2, -2, 1);\n        builder.addCube(-7, -5, -2, -5, -2, 1);\n        builder.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-2, -5, -1), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, -5, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, -2, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-2, -2, -1));\n        builder.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, -2, -0.5), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](2, -1, -0.75), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 2, -0.5));\n        builder.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](2, -1, -0.75), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](2, 2, -0.25), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 2, -0.5));\n        builder.calculateNormals();\n        this.model = builder.makeModel(this.director.gl);\n        this.collision = builder.makeCollision();\n    }\n    render() {\n        this.director.scene.pushTranslationScale(this.position, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [0.1, 0.75, 1, 1]);\n        this.director.scene.popTranslationScale();\n        for (const tri of this.collision.triangles) {\n            this.director.scene.drawArrow(tri.centroid, tri.centroid.add(tri.normal.scale(0.1)), 0.025, [1, 0, 0, 1]);\n            this.director.scene.drawArrow(tri.v1, tri.v1.add(tri.normal.scale(0.1)), 0.025, [0, 0, 1, 1]);\n            this.director.scene.drawArrow(tri.v2, tri.v2.add(tri.normal.scale(0.1)), 0.025, [0, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v1to2Center, tri.v1to2Center.add(tri.v1to2Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v2to3Center, tri.v2to3Center.add(tri.v2to3Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n            this.director.scene.drawArrow(tri.v3to1Center, tri.v3to1Center.add(tri.v3to1Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/stage1.ts?");

/***/ }),

/***/ "./src/objects/test.ts":
/*!*****************************!*\
  !*** ./src/objects/test.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Test: () => (/* binding */ Test)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stage1 */ \"./src/objects/stage1.ts\");\n\n\n\n\n\nclass Test extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\n    model;\n    position2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    speed2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n    radius = 0.15;\n    init() {\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        builder.addSphere(-this.radius, -this.radius, -this.radius, this.radius, this.radius, this.radius);\n        builder.calculateNormals();\n        this.model = builder.makeModel(this.director.gl);\n        this.position2 = this.position.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 1));\n    }\n    process() {\n        this.handleMovement1();\n        this.handleMovement2();\n        this.position = this.position.add(this.speed);\n        this.position2 = this.position2.add(this.speed);\n        this.position2 = this.position2.add(this.speed2);\n    }\n    handleMovement1() {\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\n        if (!camera)\n            return;\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](forward.y, -forward.x, 0);\n        const up = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, -1);\n        const accel = 0.005;\n        const decel = 0.015;\n        const maxSpeed = 0.05;\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n        if (!this.director.keysHeld.has(\"z\")) {\n            if (this.director.keysHeld.has(\"arrowup\") ||\n                this.director.keysHeld.has(\"w\"))\n                moveVec.y += 1;\n            if (this.director.keysHeld.has(\"arrowdown\") ||\n                this.director.keysHeld.has(\"s\"))\n                moveVec.y -= 1;\n            if (this.director.keysHeld.has(\"arrowleft\") ||\n                this.director.keysHeld.has(\"a\"))\n                moveVec.x -= 1;\n            if (this.director.keysHeld.has(\"arrowright\") ||\n                this.director.keysHeld.has(\"d\"))\n                moveVec.x += 1;\n            if (this.director.keysHeld.has(\"q\"))\n                moveVec.z -= 1;\n            if (this.director.keysHeld.has(\"e\"))\n                moveVec.z += 1;\n        }\n        moveVec = moveVec.normalized().scale(accel);\n        this.speed = this.speed\n            .add(forward.scale(moveVec.y))\n            .add(sideways.scale(moveVec.x))\n            .add(up.scale(moveVec.z));\n        const speedMagn = this.speed.magn();\n        if (speedMagn > maxSpeed)\n            this.speed = this.speed.normalized().scale(maxSpeed);\n        if (moveVec.magn() == 0) {\n            if (speedMagn > decel)\n                this.speed = this.speed.sub(this.speed.normalized().scale(decel));\n            else\n                this.speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n        }\n    }\n    handleMovement2() {\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\n        if (!camera)\n            return;\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](forward.y, -forward.x, 0);\n        const up = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, -1);\n        const accel = 0.005;\n        const decel = 0.015;\n        const maxSpeed = 0.05;\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n        if (this.director.keysHeld.has(\"z\")) {\n            if (this.director.keysHeld.has(\"arrowup\") ||\n                this.director.keysHeld.has(\"w\"))\n                moveVec.y += 1;\n            if (this.director.keysHeld.has(\"arrowdown\") ||\n                this.director.keysHeld.has(\"s\"))\n                moveVec.y -= 1;\n            if (this.director.keysHeld.has(\"arrowleft\") ||\n                this.director.keysHeld.has(\"a\"))\n                moveVec.x -= 1;\n            if (this.director.keysHeld.has(\"arrowright\") ||\n                this.director.keysHeld.has(\"d\"))\n                moveVec.x += 1;\n            if (this.director.keysHeld.has(\"q\"))\n                moveVec.z -= 1;\n            if (this.director.keysHeld.has(\"e\"))\n                moveVec.z += 1;\n        }\n        moveVec = moveVec.normalized().scale(accel);\n        this.speed2 = this.speed2\n            .add(forward.scale(moveVec.y))\n            .add(sideways.scale(moveVec.x))\n            .add(up.scale(moveVec.z));\n        const speedMagn = this.speed2.magn();\n        if (speedMagn > maxSpeed)\n            this.speed2 = this.speed2.normalized().scale(maxSpeed);\n        if (moveVec.magn() == 0) {\n            if (speedMagn > decel)\n                this.speed2 = this.speed2.sub(this.speed2.normalized().scale(decel));\n            else\n                this.speed2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 0);\n        }\n    }\n    render() {\n        const stage = this.director.objectFind(_stage1__WEBPACK_IMPORTED_MODULE_4__.Stage1);\n        if (!stage)\n            return;\n        const fromPos = this.position;\n        const toPos = this.position2;\n        const solved = stage.collision.repel(fromPos, toPos, this.radius);\n        const solvedSlide = stage.collision.repelAndSlide(fromPos, toPos, this.radius);\n        this.director.scene.pushTranslationScale(fromPos, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0, 0, 1]);\n        this.director.scene.popTranslationScale();\n        this.director.scene.pushTranslationScale(solved.position, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0.5, 0, 1]);\n        this.director.scene.popTranslationScale();\n        this.director.scene.pushTranslationScale(solvedSlide.position, this.scale);\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, 0, 1]);\n        this.director.scene.popTranslationScale();\n        this.director.scene.pushTranslationScale(solved.contact, new _math_vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0.25, 0.25, 0.25));\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0, 0, 1]);\n        this.director.scene.popTranslationScale();\n        this.director.scene.drawArrow(fromPos, toPos, 0.025, [1, 0, 0, 1]);\n        this.director.scene.drawArrow(fromPos, solvedSlide.position, 0.025, [1, 0.5, 1, 1]);\n        this.director.scene.drawArrow(fromPos, solvedSlide.position, 0.025, [1, 1, 0, 1]);\n        this.director.scene.drawArrow(solved.position, solvedSlide.position, 0.025, [1, 1, 1, 1]);\n        this.director.scene.drawArrow(solved.position, solved.position.add(solved.position.sub(solved.contact).scale(this.scale.x * 2)), 0.025, [1, 0, 0, 1]);\n        /*this.director.scene.pushTranslationScale(solved.position.add(slide), this.scale)\n        this.director.scene.drawModel(\n            this.model,\n            this.director.scene.materialColor,\n            [0, 1, 0, 1])\n        this.director.scene.popTranslationScale()\n        \n        this.director.scene.drawArrow(\n            solved.position,\n            solved.position.add(slide),\n            0.025,\n            [0, 1, 0, 1])\n\n        for (const tri of stage.collision.triangles)\n        {\n            const direction = this.position.directionToPlane(tri.normal, tri.v1)\n\n            this.director.scene.drawArrow(\n                this.position,\n                this.position.add(direction),\n                0.025,\n                [0, 1, 1, 1])\n        }*/\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/objects/test.ts?");

/***/ }),

/***/ "./src/util/collisionMesh.ts":
/*!***********************************!*\
  !*** ./src/util/collisionMesh.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollisionMesh)\n/* harmony export */ });\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/geometry */ \"./src/math/geometry.ts\");\n\n\nconst buckets = 50;\nclass CollisionMesh {\n    triangles;\n    triangleBuckets;\n    xMin = 0;\n    xMax = 0;\n    yMin = 0;\n    yMax = 0;\n    constructor() {\n        this.triangles = [];\n        this.triangleBuckets = [];\n        for (let j = 0; j < buckets; j++) {\n            this.triangleBuckets.push([]);\n            for (let i = 0; i < buckets; i++)\n                this.triangleBuckets[j].push([]);\n        }\n    }\n    addTri(v1, v2, v3) {\n        const v1to2 = v2.sub(v1);\n        const v1to3 = v3.sub(v1);\n        const v2to3 = v3.sub(v2);\n        const v3to1 = v1.sub(v3);\n        const normal = v1to2.cross(v3to1).normalized();\n        const v1to2Normal = normal.cross(v1to2).normalized();\n        const v2to3Normal = normal.cross(v2to3).normalized();\n        const v3to1Normal = normal.cross(v3to1).normalized();\n        const centroid = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((v1.x + v2.x + v3.x) / 3, (v1.y + v2.y + v3.y) / 3, (v1.z + v2.z + v3.z) / 3);\n        const v1to2Center = v1.lerp(v2, 0.5);\n        const v2to3Center = v2.lerp(v3, 0.5);\n        const v3to1Center = v3.lerp(v1, 0.5);\n        const tri = {\n            index: this.triangles.length,\n            v1, v2, v3, v1to2, v1to3, v2to3, v3to1,\n            normal, v1to2Normal, v3to1Normal, v2to3Normal,\n            centroid, v1to2Center, v3to1Center, v2to3Center,\n        };\n        this.triangles.push(tri);\n        this.xMin = Math.min(this.xMin, v1.x, v2.x, v3.x);\n        this.xMax = Math.max(this.xMax, v1.x, v2.x, v3.x);\n        this.yMin = Math.min(this.yMin, v1.y, v2.y, v3.y);\n        this.yMax = Math.max(this.yMax, v1.y, v2.y, v3.y);\n    }\n    build() {\n        for (const tri of this.triangles) {\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v1));\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v2));\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v3));\n        }\n    }\n    addToNearBuckets(tri, bucketIndex) {\n        this.addToBucket(tri, bucketIndex);\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y });\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y });\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y - 1 });\n        this.addToBucket(tri, { x: bucketIndex.x + 0, y: bucketIndex.y - 1 });\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y - 1 });\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y + 1 });\n        this.addToBucket(tri, { x: bucketIndex.x + 0, y: bucketIndex.y + 1 });\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y + 1 });\n    }\n    addToBucket(tri, bucketIndex) {\n        if (bucketIndex.x < 0 || bucketIndex.x >= buckets)\n            return;\n        if (bucketIndex.y < 0 || bucketIndex.y >= buckets)\n            return;\n        const bucket = this.triangleBuckets[bucketIndex.y][bucketIndex.x];\n        if (!bucket.find(t => t === tri))\n            bucket.push(tri);\n    }\n    bucketForPosition(pos) {\n        const x = Math.max(0, Math.floor((pos.x - this.xMin) / (this.xMax - this.xMin) * buckets) % buckets);\n        const y = Math.max(0, Math.floor((pos.y - this.yMin) / (this.yMax - this.yMin) * buckets) % buckets);\n        return { x, y };\n    }\n    *enumerateTrianglesByBuckets(pos) {\n        const bucketIndex = this.bucketForPosition(pos);\n        for (const tri of this.triangleBuckets[bucketIndex.y][bucketIndex.x])\n            yield tri;\n    }\n    repelAndSlide(posPrev, pos, radius) {\n        let contact = pos;\n        let collided = false;\n        for (let i = 0; i < 2; i++) {\n            const solved = this.repel(posPrev, pos, radius);\n            posPrev = solved.position;\n            if (!solved.collided)\n                break;\n            collided = true;\n            contact = solved.contact;\n            const slideVec = pos.sub(solved.position).projectOnPlane(solved.position.sub(solved.contact));\n            pos = posPrev.add(slideVec);\n        }\n        return {\n            position: posPrev,\n            contact,\n            collided,\n        };\n    }\n    collideAndSlide(posPrev, pos, radius) {\n        let contact = pos;\n        let collided = false;\n        for (let i = 0; i < 3; i++) {\n            const solved = this.collide(posPrev, pos, radius);\n            posPrev = solved.position;\n            if (!solved.collided)\n                break;\n            collided = true;\n            contact = solved.contact;\n            const extraSpeed = pos.sub(solved.position);\n            const slideVec = extraSpeed.projectOnPlane(solved.position.sub(solved.contact));\n            pos = posPrev.add(slideVec);\n        }\n        return {\n            position: posPrev,\n            contact,\n            collided,\n        };\n    }\n    repel(posPrev, pos, radius) {\n        let solvedPos = pos;\n        let solvedT = Infinity;\n        let contact = pos;\n        let collided = false;\n        for (const tri of this.enumerateTrianglesByBuckets(pos)) {\n            const triSolved = this.repelTriangle(tri, posPrev, pos, radius);\n            if (!triSolved)\n                continue;\n            const triSolvedT = triSolved.position.sub(posPrev).projectT(pos.sub(posPrev));\n            if (triSolvedT < solvedT) {\n                solvedPos = triSolved.position;\n                solvedT = triSolvedT;\n                contact = triSolved.contact;\n                collided = true;\n            }\n        }\n        return {\n            position: solvedPos,\n            contact,\n            collided,\n        };\n    }\n    collide(posPrev, pos, radius) {\n        let t = 1;\n        let contact = pos;\n        for (const tri of this.triangles) {\n            const triSolved = this.collideTriangle(tri, posPrev, pos, radius);\n            if (!triSolved)\n                continue;\n            if (triSolved.t < t) {\n                t = triSolved.t;\n                contact = triSolved.contact;\n            }\n        }\n        return {\n            position: posPrev.add(pos.sub(posPrev).scale(t)),\n            contact,\n            collided: t < 1,\n        };\n    }\n    repelTriangle(tri, posPrev, pos, radius) {\n        const speed = pos.sub(posPrev);\n        const speedNorm = speed.normalized();\n        const sqrRadius = radius * radius;\n        const sqrDistPlanePrev = posPrev.signedSqrDistanceToPlane(tri.normal, tri.v1);\n        if (sqrDistPlanePrev <= -sqrRadius)\n            return null;\n        const sqrDistPlane = pos.signedSqrDistanceToPlane(tri.normal, tri.v1);\n        if (sqrDistPlane >= sqrRadius)\n            return null;\n        //const sqrDistEdge1 = pos.signedSqrDistanceToPlane(tri.v1to2Normal, tri.v1)\n        //const sqrDistEdge2 = pos.signedSqrDistanceToPlane(tri.v2to3Normal, tri.v2)\n        //const sqrDistEdge3 = pos.signedSqrDistanceToPlane(tri.v3to1Normal, tri.v3)\n        const sqrDistEdge1 = pos.signedSqrDistanceToPlane(tri.v1to2.normalized().cross(speedNorm), tri.v1);\n        const sqrDistEdge2 = pos.signedSqrDistanceToPlane(tri.v2to3.normalized().cross(speedNorm), tri.v2);\n        const sqrDistEdge3 = pos.signedSqrDistanceToPlane(tri.v3to1.normalized().cross(speedNorm), tri.v3);\n        if (sqrDistEdge1 >= sqrRadius || sqrDistEdge2 >= sqrRadius || sqrDistEdge3 >= sqrRadius)\n            return null;\n        const repelledFromSpeed = speed; //Math.sqrt(Math.abs(sqrDistPlane)) + radius * 2)\n        const repelledFromPos = pos.sub(repelledFromSpeed);\n        const repelledCollision = this.collideTriangle(tri, repelledFromPos, repelledFromPos.add(repelledFromSpeed), radius);\n        if (!repelledCollision)\n            return null;\n        return {\n            position: repelledFromPos.add(repelledFromSpeed.scale(repelledCollision.t).withAddedMagn(-radius * 0.01)),\n            contact: repelledCollision.contact,\n        };\n    }\n    collideTriangle(tri, posPrev, pos, radius) {\n        const radiusNormal = tri.normal.scale(radius);\n        const speed = pos.sub(posPrev);\n        const dotPrevNormal = tri.normal.dot(posPrev.sub(radiusNormal).sub(tri.v1));\n        //console.log(\"dotPrevNormal\", dotPrevNormal)\n        //if (dotPrevNormal < 0)\n        //\treturn null\n        const dotNormal = tri.normal.dot(pos.sub(radiusNormal).sub(tri.v1));\n        //console.log(\"dotNormal\", dotNormal)\n        //if (dotNormal > 0)\n        //\treturn null\n        const speedDotNormal = tri.normal.dot(speed);\n        let tPlane = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPlane(posPrev, speed, radius, tri.v1, tri.normal);\n        const contactPlane = posPrev.sub(tri.normal.scale(radius)).add(speed.scale(tPlane));\n        const dotPlane1 = contactPlane.sub(tri.v1).dot(tri.v1to2Normal);\n        const dotPlane2 = contactPlane.sub(tri.v2).dot(tri.v2to3Normal);\n        const dotPlane3 = contactPlane.sub(tri.v3).dot(tri.v3to1Normal);\n        if (dotPlane1 > 0 || dotPlane2 > 0 || dotPlane3 > 0)\n            tPlane = Infinity;\n        const tE1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v1, tri.v1to2);\n        const tE2 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v2, tri.v2to3);\n        const tE3 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v3, tri.v3to1);\n        const tV1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v1);\n        const tV2 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v2);\n        const tV3 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v3);\n        const t = Math.min(tPlane, tE1, tE2, tE3, tV1, tV2, tV3);\n        //if (speedDotNormal >= 0 && (t < 0 || t > 1))\n        //\treturn null\n        //if (speedDotNormal < 0 && (t < -0.5 || t > 1))\n        //\treturn null\n        if (t < 0 || t > 1)\n            return null;\n        if (!isFinite(t))\n            return null;\n        if (tPlane < tE1 && tPlane < tE2 && tPlane < tE3 && tPlane < tV1 && tPlane < tV2 && tPlane < tV3)\n            return { t: tPlane, contact: contactPlane };\n        if (tE1 < tE2 && tE1 < tE3 && tE1 < tV1 && tE1 < tV2 && tE1 < tV3) {\n            const pE1 = posPrev.add(speed.scale(tE1));\n            return { t: tE1, contact: pE1.sub(pE1.directionToLine(tri.v1to2, tri.v1)) };\n        }\n        if (tE2 < tE3 && tE2 < tV1 && tE2 < tV2 && tE2 < tV3) {\n            const pE2 = posPrev.add(speed.scale(tE2));\n            return { t: tE2, contact: pE2.sub(pE2.directionToLine(tri.v2to3, tri.v2)) };\n        }\n        if (tE3 < tV1 && tE3 < tV2 && tE3 < tV3) {\n            const pE3 = posPrev.add(speed.scale(tE3));\n            return { t: tE3, contact: pE3.sub(pE3.directionToLine(tri.v3to1, tri.v3)) };\n        }\n        if (tV1 < tV2 && tE3 < tV3) {\n            return { t: tV1, contact: tri.v1 };\n        }\n        if (tV2 < tV3) {\n            return { t: tV2, contact: tri.v2 };\n        }\n        return { t: tV3, contact: tri.v3 };\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/util/collisionMesh.ts?");

/***/ }),

/***/ "./src/util/modelBuilder.ts":
/*!**********************************!*\
  !*** ./src/util/modelBuilder.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ModelBuilder)\n/* harmony export */ });\n/* harmony import */ var _gl_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gl/model */ \"./src/gl/model.ts\");\n/* harmony import */ var _gl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gl/buffer */ \"./src/gl/buffer.ts\");\n/* harmony import */ var _collisionMesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collisionMesh */ \"./src/util/collisionMesh.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\n\n\n\n\nclass ModelBuilder {\n    positions;\n    normals;\n    colors;\n    constructor() {\n        this.positions = [];\n        this.normals = [];\n        this.colors = [];\n    }\n    addTri(v1, v2, v3, c1, c2, c3) {\n        this.positions.push(v1);\n        this.positions.push(v2);\n        this.positions.push(v3);\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0, 0, 0));\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0, 0, 0));\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0, 0, 0));\n        this.colors.push(c1 ? c1 : [1, 1, 1, 1]);\n        this.colors.push(c2 ? c2 : [1, 1, 1, 1]);\n        this.colors.push(c3 ? c3 : [1, 1, 1, 1]);\n        return this;\n    }\n    addQuad(v1, v2, v3, v4, c1, c2, c3, c4) {\n        this.addTri(v1, v2, v3, c1, c2, c3);\n        this.addTri(v1, v3, v4, c1, c3, c4);\n        return this;\n    }\n    addQuadSubdiv(v1, v2, v3, v4, subdivs) {\n        for (let j = 0; j < subdivs; j++) {\n            for (let i = 0; i < subdivs; i++) {\n                let p1 = v1.lerp(v2, (i + 0) / subdivs);\n                let p2 = v1.lerp(v2, (i + 1) / subdivs);\n                let p3 = v4.lerp(v3, (i + 1) / subdivs);\n                let p4 = v4.lerp(v3, (i + 0) / subdivs);\n                let f1 = p1.lerp(p4, (j + 0) / subdivs);\n                let f2 = p2.lerp(p3, (j + 0) / subdivs);\n                let f3 = p2.lerp(p3, (j + 1) / subdivs);\n                let f4 = p1.lerp(p4, (j + 1) / subdivs);\n                this.addQuad(f1, f2, f3, f4);\n            }\n        }\n        return this;\n    }\n    addCube(x1, y1, z1, x2, y2, z2, subdivs = 1) {\n        let v1Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x1, y1, z1);\n        let v2Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x2, y1, z1);\n        let v3Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x2, y2, z1);\n        let v4Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x1, y2, z1);\n        let v1Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x1, y1, z2);\n        let v2Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x2, y1, z2);\n        let v3Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x2, y2, z2);\n        let v4Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](x1, y2, z2);\n        this.addQuadSubdiv(v1Top, v2Top, v3Top, v4Top, subdivs);\n        this.addQuadSubdiv(v1Bot, v4Bot, v3Bot, v2Bot, subdivs);\n        this.addQuadSubdiv(v2Top, v1Top, v1Bot, v2Bot, subdivs);\n        this.addQuadSubdiv(v3Top, v2Top, v2Bot, v3Bot, subdivs);\n        this.addQuadSubdiv(v4Top, v3Top, v3Bot, v4Bot, subdivs);\n        this.addQuadSubdiv(v1Top, v4Top, v4Bot, v1Bot, subdivs);\n        return this;\n    }\n    addSphere(x1, y1, z1, x2, y2, z2, subdivs = 8) {\n        let index = this.positions.length;\n        this.addCube(x1, y1, z1, x2, y2, z2, subdivs);\n        let c = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"]((x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);\n        let size = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](Math.abs(x2 - x1) / 2, Math.abs(y2 - y1) / 2, Math.abs(z2 - z1) / 2);\n        for (let i = index; i < this.positions.length; i++)\n            this.positions[i] = c.add(this.positions[i].sub(c).normalized().mul(size));\n        return this;\n    }\n    addCone(x1, y1, z1, x2, y2, z2, subdivs = 8, upVec) {\n        let index = this.positions.length;\n        let cx = (x1 + x2) / 2;\n        let cy = (y1 + y2) / 2;\n        let sx = (x2 - x1) / 2;\n        let sy = (y2 - y1) / 2;\n        for (let i = 0; i < subdivs; i++) {\n            let angle0 = (i + 0) / subdivs * Math.PI * 2;\n            let angle1 = (i + 1) / subdivs * Math.PI * 2;\n            let cos0 = Math.cos(angle0);\n            let cos1 = Math.cos(angle1);\n            let sin0 = Math.sin(angle0);\n            let sin1 = Math.sin(angle1);\n            // Lid\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx, cy, z1));\n            // Edge\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx, cy, z2));\n        }\n        if (upVec != null) {\n            let matrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0, 0, -1), upVec);\n            for (let i = index; i < this.positions.length; i++)\n                this.positions[i] = matrix.mulPoint(this.positions[i]);\n        }\n        return this;\n    }\n    addCylinder(x1, y1, z1, x2, y2, z2, subdivs = 8, upVec) {\n        let index = this.positions.length;\n        let cx = (x1 + x2) / 2;\n        let cy = (y1 + y2) / 2;\n        let sx = (x2 - x1) / 2;\n        let sy = (y2 - y1) / 2;\n        for (let i = 0; i < subdivs; i++) {\n            let angle0 = (i + 0) / subdivs * Math.PI * 2;\n            let angle1 = (i + 1) / subdivs * Math.PI * 2;\n            let cos0 = Math.cos(angle0);\n            let cos1 = Math.cos(angle1);\n            let sin0 = Math.sin(angle0);\n            let sin1 = Math.sin(angle1);\n            // Lid\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx, cy, z1));\n            // Bottom\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx, cy, z2));\n            // Edge\n            this.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos0 * sx, cy + sin0 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](cx + cos1 * sx, cy + sin1 * sy, z2));\n        }\n        if (upVec != null) {\n            let matrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0, 0, -1), upVec);\n            for (let i = index; i < this.positions.length; i++)\n                this.positions[i] = matrix.mulPoint(this.positions[i]);\n        }\n        return this;\n    }\n    /*getBoundingBox()\n    {\n        let bbox =\n        {\n            xMin: null,\n            yMin: null,\n            zMin: null,\n            xMax: null,\n            yMax: null,\n            zMax: null\n        }\n        \n        for (let pos of this.positions)\n        {\n            bbox.xMin = (bbox.xMin == null ? pos.x : Math.min(bbox.xMin, pos.x))\n            bbox.yMin = (bbox.xMin == null ? pos.y : Math.min(bbox.yMin, pos.y))\n            bbox.zMin = (bbox.xMin == null ? pos.z : Math.min(bbox.zMin, pos.z))\n            bbox.xMax = (bbox.xMax == null ? pos.x : Math.max(bbox.xMax, pos.x))\n            bbox.yMax = (bbox.xMax == null ? pos.y : Math.max(bbox.yMax, pos.y))\n            bbox.zMax = (bbox.xMax == null ? pos.z : Math.max(bbox.zMax, pos.z))\n        }\n        \n        bbox.xSize = (bbox.xMax - bbox.xMin)\n        bbox.ySize = (bbox.yMax - bbox.yMin)\n        bbox.zSize = (bbox.zMax - bbox.zMin)\n        \n        bbox.xCenter = (bbox.xMin + bbox.xMax) / 2\n        bbox.yCenter = (bbox.yMin + bbox.yMax) / 2\n        bbox.zCenter = (bbox.zMin + bbox.zMax) / 2\n        \n        return bbox\n    }\n    \n    \n    getSaneBoundingBox(maxSize: number = 100000)\n    {\n        let center = this.getMedianCenter()\n        \n        let bbox =\n        {\n            xMin: null,\n            yMin: null,\n            zMin: null,\n            xMax: null,\n            yMax: null,\n            zMax: null\n        }\n        \n        for (let pos of this.positions)\n        {\n            if (Math.abs(pos.x - center.x) < maxSize)\n            {\n                bbox.xMin = (bbox.xMin == null ? pos.x : Math.min(bbox.xMin, pos.x))\n                bbox.xMax = (bbox.xMax == null ? pos.x : Math.max(bbox.xMax, pos.x))\n            }\n            \n            if (Math.abs(pos.y - center.y) < maxSize)\n            {\n                bbox.yMin = (bbox.xMin == null ? pos.y : Math.min(bbox.yMin, pos.y))\n                bbox.yMax = (bbox.xMax == null ? pos.y : Math.max(bbox.yMax, pos.y))\n            }\n            \n            if (Math.abs(pos.z - center.z) < maxSize)\n            {\n                bbox.zMin = (bbox.xMin == null ? pos.z : Math.min(bbox.zMin, pos.z))\n                bbox.zMax = (bbox.xMax == null ? pos.z : Math.max(bbox.zMax, pos.z))\n            }\n        }\n        \n        bbox.xSize = (bbox.xMax - bbox.xMin)\n        bbox.ySize = (bbox.yMax - bbox.yMin)\n        bbox.zSize = (bbox.zMax - bbox.zMin)\n        \n        bbox.xCenter = (bbox.xMin + bbox.xMax) / 2\n        bbox.yCenter = (bbox.yMin + bbox.yMax) / 2\n        bbox.zCenter = (bbox.zMin + bbox.zMax) / 2\n        \n        return bbox\n    }*/\n    getMedianCenter() {\n        if (this.positions.length == 0)\n            return { x: 0, y: 0, z: 0 };\n        let xs = [];\n        let ys = [];\n        let zs = [];\n        for (let pos of this.positions) {\n            xs.push(pos.x);\n            ys.push(pos.y);\n            zs.push(pos.z);\n        }\n        xs.sort((a, b) => a - b);\n        ys.sort((a, b) => a - b);\n        zs.sort((a, b) => a - b);\n        return {\n            x: xs[Math.floor(xs.length / 2)],\n            y: ys[Math.floor(xs.length / 2)],\n            z: zs[Math.floor(xs.length / 2)]\n        };\n    }\n    makeDoubleSided() {\n        let len = this.positions.length;\n        for (let i = 0; i < len; i += 3) {\n            let v1 = this.positions[i + 0];\n            let v2 = this.positions[i + 1];\n            let v3 = this.positions[i + 2];\n            this.addTri(v1, v3, v2);\n        }\n        return this;\n    }\n    calculateNormals(maxSmoothAngle = 1.5) {\n        for (let i = 0; i < this.positions.length; i += 3) {\n            let v1 = this.positions[i + 0];\n            let v2 = this.positions[i + 1];\n            let v3 = this.positions[i + 2];\n            let v1to2 = v2.sub(v1);\n            let v1to3 = v3.sub(v1);\n            let normal = v1to2.cross(v1to3).normalized();\n            this.normals[i + 0] = normal;\n            this.normals[i + 1] = normal;\n            this.normals[i + 2] = normal;\n        }\n        // Disable slow smooth-shading calculations for now\n        return this;\n        /*const rounding = 0.001\n        const hash = (vec) =>\n        {\n            return (\n                (Math.round(vec.x * rounding) / rounding) * 1000000 +\n                (Math.round(vec.y * rounding) / rounding) * 1000 +\n                (Math.round(vec.z * rounding) / rounding))\n        }\n        \n        let verticesSet = new Map()\n        for (let j = 0; j < this.positions.length; j++)\n        {\n            let key = hash(this.positions[j])\n            \n            let value = verticesSet.get(key)\n            if (value === undefined)\n                verticesSet.set(key, [j])\n            else\n                value.push(j)\n        }\n        \n        let normalAccum = []\n        let normalCount = []\n        for (let j = 0; j < this.positions.length; j++)\n        {\n            normalAccum[j] = this.normals[j]\n            normalCount[j] = 1\n            \n            let vertices = verticesSet.get(hash(this.positions[j]))\n            if (vertices === undefined)\n                continue\n            \n            for (let i of vertices)\n            {\n                if (i == j)\n                    continue\n                \n                if (Math.abs(Math.acos(this.normals[j].dot(this.normals[i]))) <= maxSmoothAngle)\n                {\n                    normalAccum[j] = normalAccum[j].add(this.normals[i])\n                    normalCount[j] += 1\n                }\n            }\n        }\n        \n        for (let i = 0; i < this.positions.length; i++)\n            this.normals[i] = normalAccum[i].scale(1 / normalCount[i]).normalize()\n        \n        return this*/\n    }\n    makeModel(gl) {\n        let positions = [];\n        let normals = [];\n        let colors = [];\n        for (let i = 0; i < this.positions.length; i++) {\n            positions.push(this.positions[i].x);\n            positions.push(this.positions[i].y);\n            positions.push(this.positions[i].z);\n            normals.push(this.normals[i].x);\n            normals.push(this.normals[i].y);\n            normals.push(this.normals[i].z);\n            colors.push(this.colors[i][0]);\n            colors.push(this.colors[i][1]);\n            colors.push(this.colors[i][2]);\n            colors.push(this.colors[i][3]);\n        }\n        let model = new _gl_model__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n            .setPositions(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makePosition(gl, positions))\n            .setNormals(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makeNormal(gl, normals))\n            .setColors(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makeColor(gl, colors));\n        return model;\n    }\n    makeCollision() {\n        let col = new _collisionMesh__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        for (let i = 0; i < this.positions.length; i += 3)\n            col.addTri(this.positions[i + 0], this.positions[i + 1], this.positions[i + 2]);\n        col.build();\n        return col;\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/util/modelBuilder.ts?");

/***/ }),

/***/ "./src/util/objLoader.ts":
/*!*******************************!*\
  !*** ./src/util/objLoader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjLoader: () => (/* binding */ ObjLoader)\n/* harmony export */ });\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\n\nclass ObjLoader {\n    static load(bytes) {\n        let str = new TextDecoder(\"utf-8\").decode(bytes);\n        let lines = str.replace(\"\\r\\n\", \"\\n\").split(\"\\n\").map(s => s.trim());\n        let objects = [];\n        let curObject = null;\n        let curGeometry = null;\n        for (let line of lines) {\n            if (line.startsWith(\"#\"))\n                continue;\n            let tagO = line.match(/^o[ ]+(.*)/);\n            if (tagO != null) {\n                let object = {};\n                object.name = tagO[1];\n                object.vertices = [];\n                object.normals = [];\n                object.texCoords = [];\n                object.geometries = [];\n                objects.push(object);\n                curObject = object;\n                continue;\n            }\n            if (curObject == null) {\n                let object = {};\n                object.name = \"Default Object\";\n                object.vertices = [];\n                object.normals = [];\n                object.texCoords = [];\n                object.geometries = [];\n                objects.push(object);\n                curObject = object;\n            }\n            let tagV = line.match(/^v[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\n            if (tagV != null) {\n                let vertex = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](parseFloat(tagV[1]), -parseFloat(tagV[3]), -parseFloat(tagV[2]));\n                curObject.vertices.push(vertex);\n                continue;\n            }\n            let tagVT = line.match(/^vt[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\n            if (tagVT != null) {\n                let texCoord = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](parseFloat(tagVT[1]), parseFloat(tagVT[2]), 0);\n                curObject.texCoords.push(texCoord);\n                continue;\n            }\n            let tagVN = line.match(/^vn[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\n            if (tagVN != null) {\n                let normal = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](parseFloat(tagVN[1]), parseFloat(tagVN[2]), parseFloat(tagVN[3]));\n                curObject.normals.push(normal);\n                continue;\n            }\n            let tagG = line.match(/^g[ ]+(.*)/);\n            if (tagG != null) {\n                let geometry = {};\n                geometry.name = tagG[1];\n                geometry.faces = [];\n                curObject.geometries.push(geometry);\n                curGeometry = geometry;\n                continue;\n            }\n            if (curGeometry == null)\n                continue;\n            if (line.startsWith(\"f\")) {\n                let splits = line.substr(1).split(\" \").map(v => v.trim());\n                let face = [];\n                for (let split of splits) {\n                    if (split == \"\")\n                        continue;\n                    let indices = split.split(\"/\");\n                    let vertex = {};\n                    vertex.position = curObject.vertices[parseInt(indices[0]) - 1];\n                    vertex.texCoord = (indices.length < 2 ? new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0) : curObject.texCoords[parseInt(indices[1]) - 1]);\n                    vertex.normal = (indices.length < 3 ? new _math_vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0) : curObject.normals[parseInt(indices[2]) - 1]);\n                    if (vertex.position)\n                        face.push(vertex);\n                }\n                curGeometry.faces.push(face);\n                continue;\n            }\n        }\n        return objects;\n    }\n    static makeModelBuilder(bytes) {\n        let objects = ObjLoader.load(bytes);\n        console.log(objects);\n        let model = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        for (let object of objects) {\n            for (let geometry of object.geometries) {\n                for (let face of geometry.faces) {\n                    if (face.length >= 3) {\n                        model.addTri(face[0].position, face[1].position, face[2].position);\n                        model.addTri(face[0].position, face[2].position, face[1].position);\n                    }\n                }\n            }\n        }\n        return model.calculateNormals();\n    }\n}\n\n\n//# sourceURL=webpack://platformer/./src/util/objLoader.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;