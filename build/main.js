(()=>{"use strict";class t{constructor(t,s,i){this.x=t,this.y=s,this.z=i}clone(){return new t(this.x,this.y,this.z)}magn(){return Math.sqrt(this.dot(this))}magnSqr(){return this.dot(this)}withZ(s){return new t(this.x,this.y,s)}withMagn(t){return this.normalized().scale(t)}withAddedMagn(t){return this.normalized().scale(this.magn()+t)}normalized(){const s=this.magn();return 0==s?this:new t(this.x/s,this.y/s,this.z/s)}add(s){return new t(this.x+s.x,this.y+s.y,this.z+s.z)}sub(s){return new t(this.x-s.x,this.y-s.y,this.z-s.z)}neg(){return new t(-this.x,-this.y,-this.z)}scale(s){return new t(this.x*s,this.y*s,this.z*s)}mul(s){return new t(this.x*s.x,this.y*s.y,this.z*s.z)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(s){return new t(this.y*s.z-this.z*s.y,this.z*s.x-this.x*s.z,this.x*s.y-this.y*s.x)}lerp(s,i){return new t(this.x+(s.x-this.x)*i,this.y+(s.y-this.y)*i,this.z+(s.z-this.z)*i)}min(s){return null==s?this:new t(Math.min(this.x,s.x),Math.min(this.y,s.y),Math.min(this.z,s.z))}max(s){return null==s?this:new t(Math.max(this.x,s.x),Math.max(this.y,s.y),Math.max(this.z,s.z))}projectT(t){return this.dot(t)/t.dot(t)}project(t){return t.scale(this.dot(t)/t.dot(t))}projectOnPlane(t){return this.sub(this.project(t))}directionToLine(t,s){const i=this.sub(s);return i.sub(i.project(t))}directionToPlane(t,s){const i=this.sub(s);return i.sub(i.project(t)).add(s).sub(this)}signedSqrDistanceToPlane(t,s){const i=this.directionToPlane(t,s),e=this.sub(s).dot(t);return i.magnSqr()*Math.sign(e)}asArray(){return[this.x,this.y,this.z]}isFinite(){return isFinite(this.x)&&isFinite(this.y)&&isFinite(this.z)}}class s{constructor(t){this.m=new Float32Array(t)}static identity(){return i}static translation(t,i,e){return new s([1,0,0,0,0,1,0,0,0,0,1,0,t,i,e,1])}static scale(t,i,e){return new s([t,0,0,0,0,i,0,0,0,0,e,0,0,0,0,1])}static rotation(t,i){const e=t.x,o=t.y,r=t.z,n=Math.cos(i),h=Math.sin(i),a=1-n;return new s([a*e*e+n,a*e*o-r*h,a*e*r+o*h,0,a*e*o+r*h,a*o*o+n,a*o*r-e*h,0,a*e*r-o*h,a*o*r+e*h,a*r*r+n,0,0,0,0,1])}static rotationFromTo(t,i){const e=t.cross(i).normalized(),o=Math.acos(t.dot(i));return s.rotation(e,-o)}static basisRotation(t,i,e,o,r,n){const h=new s([t.x,i.x,e.x,0,t.y,i.y,e.y,0,t.z,i.z,e.z,0,0,0,0,1]),a=new s([o.x,r.x,n.x,0,o.y,r.y,n.y,0,o.z,r.z,n.z,0,0,0,0,1]);return h.mul(a.transpose())}static ortho(t,i,e,o,r,n){return new s([2/(i-t),0,0,0,0,2/(e-o),0,0,0,0,-2/(n-r),0,-(i+t)/(i-t),-(e+o)/(e-o),-(n+r)/(n-r),1])}static frustum(t,i,e,o,r,n){return new s([2*r/(i-t),0,0,0,0,2*r/(e-o),0,0,(i+t)/(i-t),(e+o)/(e-o),-(n+r)/(n-r),-1,0,0,-2*n*r/(n-r),0])}static perspective(t,i,e,o){const r=Math.tan(t)*e,n=r*i;return s.frustum(-n,n,-r,r,e,o)}static lookat(t,i,e){const o=t.sub(i).normalized(),r=o.cross(e).normalized(),n=o.cross(r);return new s([r.x,n.x,o.x,0,r.y,n.y,o.y,0,r.z,n.z,o.z,0,-r.dot(t),-n.dot(t),-o.dot(t),1])}transpose(){return new s([this.m[0],this.m[4],this.m[8],this.m[12],this.m[1],this.m[5],this.m[9],this.m[13],this.m[2],this.m[6],this.m[10],this.m[14],this.m[3],this.m[7],this.m[11],this.m[15]])}mul(t){if(this===i)return t;if(t===i)return this;const e=+this.m[0],o=+this.m[1],r=+this.m[2],n=+this.m[3],h=+this.m[4],a=+this.m[5],l=+this.m[6],d=+this.m[7],c=+this.m[8],m=+this.m[9],u=+this.m[10],p=+this.m[11],w=+this.m[12],f=+this.m[13],g=+this.m[14],y=+this.m[15],b=+t.m[0],v=+t.m[1],x=+t.m[2],k=+t.m[3],M=+t.m[4],z=+t.m[5],C=+t.m[6],S=+t.m[7],T=+t.m[8],P=+t.m[9],A=+t.m[10],F=+t.m[11],N=+t.m[12],j=+t.m[13],H=+t.m[14],D=+t.m[15];return new s([e*b+o*M+r*T+n*N,e*v+o*z+r*P+n*j,e*x+o*C+r*A+n*H,e*k+o*S+r*F+n*D,h*b+a*M+l*T+d*N,h*v+a*z+l*P+d*j,h*x+a*C+l*A+d*H,h*k+a*S+l*F+d*D,c*b+m*M+u*T+p*N,c*v+m*z+u*P+p*j,c*x+m*C+u*A+p*H,c*k+m*S+u*F+p*D,w*b+f*M+g*T+y*N,w*v+f*z+g*P+y*j,w*x+f*C+g*A+y*H,w*k+f*S+g*F+y*D])}mulVec4(t){let s=[0,0,0,0];for(let i=0;i<4;i++){let e=0;for(let s=0;s<4;s++)e+=this.m[4*i+s]*t[s];s[i]=e}return s}mulPoint(s){const i=[s.x,s.y,s.z,1];let e=[0,0,0,0];for(let t=0;t<4;t++){let s=0;for(let e=0;e<4;e++)s+=this.m[4*t+e]*i[e];e[t]=s}return new t(e[0],e[1],e[2])}mulDirection(s){const i=[s.x,s.y,s.z,0];let e=[0,0,0,0];for(let t=0;t<4;t++){let s=0;for(let e=0;e<4;e++)s+=this.m[4*t+e]*i[e];e[t]=s}return new t(e[0],e[1],e[2])}asFloat32Array(){return this.m}invert(){const t=this.m[10]*this.m[15]-this.m[11]*this.m[14],i=this.m[9]*this.m[15]-this.m[11]*this.m[13],e=this.m[9]*this.m[14]-this.m[10]*this.m[13],o=this.m[8]*this.m[15]-this.m[11]*this.m[12],r=this.m[8]*this.m[14]-this.m[10]*this.m[12],n=this.m[8]*this.m[13]-this.m[9]*this.m[12],h=this.m[6]*this.m[15]-this.m[7]*this.m[14],a=this.m[5]*this.m[15]-this.m[7]*this.m[13],l=this.m[5]*this.m[14]-this.m[6]*this.m[13],d=this.m[6]*this.m[11]-this.m[7]*this.m[10],c=this.m[5]*this.m[11]-this.m[7]*this.m[9],m=this.m[5]*this.m[10]-this.m[6]*this.m[9],u=this.m[4]*this.m[15]-this.m[7]*this.m[12],p=this.m[4]*this.m[14]-this.m[6]*this.m[12],w=this.m[4]*this.m[11]-this.m[7]*this.m[8],f=this.m[4]*this.m[10]-this.m[6]*this.m[8],g=this.m[4]*this.m[13]-this.m[5]*this.m[12],y=this.m[4]*this.m[9]-this.m[5]*this.m[8],b=1/(this.m[0]*(this.m[5]*t-this.m[6]*i+this.m[7]*e)-this.m[1]*(this.m[4]*t-this.m[6]*o+this.m[7]*r)+this.m[2]*(this.m[4]*i-this.m[5]*o+this.m[7]*n)-this.m[3]*(this.m[4]*e-this.m[5]*r+this.m[6]*n));return new s([b*(this.m[5]*t-this.m[6]*i+this.m[7]*e),b*-(this.m[1]*t-this.m[2]*i+this.m[3]*e),b*(this.m[1]*h-this.m[2]*a+this.m[3]*l),b*-(this.m[1]*d-this.m[2]*c+this.m[3]*m),b*-(this.m[4]*t-this.m[6]*o+this.m[7]*r),b*(this.m[0]*t-this.m[2]*o+this.m[3]*r),b*-(this.m[0]*h-this.m[2]*u+this.m[3]*p),b*(this.m[0]*d-this.m[2]*w+this.m[3]*f),b*(this.m[4]*i-this.m[5]*o+this.m[7]*n),b*-(this.m[0]*i-this.m[1]*o+this.m[3]*n),b*(this.m[0]*a-this.m[1]*u+this.m[3]*g),b*-(this.m[0]*c-this.m[1]*w+this.m[3]*y),b*-(this.m[4]*e-this.m[5]*r+this.m[6]*n),b*(this.m[0]*e-this.m[1]*r+this.m[2]*n),b*-(this.m[0]*l-this.m[1]*p+this.m[2]*g),b*(this.m[0]*m-this.m[1]*f+this.m[2]*y)]).transpose()}}const i=new s([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class e{constructor(t){this.id=t}static makeVertex(t,s){return e.make(t,s,t.VERTEX_SHADER)}static makeFragment(t,s){return e.make(t,s,t.FRAGMENT_SHADER)}static make(t,s,i){let o=t.createShader(i);return t.shaderSource(o,s),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)?new e(o):(console.error("Error compiling shader: \n\n"+t.getShaderInfoLog(o)),t.deleteShader(o),null)}}class o{constructor(t){this.id=t,this.attributes={},this.uniforms={},this.hasColor=!1}static makeFromSrc(t,s,i){let r=e.makeVertex(t,s);if(null==r)throw"vertexShader null";let n=e.makeFragment(t,i);if(null==n)throw"fragmentShader null";return o.make(t,r,n)}static make(t,s,i){let e=t.createProgram();if(t.attachShader(e,s.id),t.attachShader(e,i.id),t.linkProgram(e),!t.getProgramParameter(e,t.LINK_STATUS))throw console.error("Error creating program: \n\n"+t.getProgramInfoLog(e)),t.deleteProgram(e),"GLProgram.make error";return new o(e)}registerLocations(t,s,i){for(let i of s)this.attributes[i]=t.getAttribLocation(this.id,i);for(let s of i)this.uniforms[s]=t.getUniformLocation(this.id,s);return this.hasColor=null!=s.find((t=>"aColor"==t)),this}use(t){return t.useProgram(this.id),this}bindPosition(t,s,i){return t.bindBuffer(t.ARRAY_BUFFER,i.id),t.vertexAttribPointer(this.attributes[s],3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.attributes[s]),this}bindNormals(t,s,i){return t.bindBuffer(t.ARRAY_BUFFER,i.id),t.vertexAttribPointer(this.attributes[s],3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.attributes[s]),this}bindColors(t,s,i){return t.bindBuffer(t.ARRAY_BUFFER,i.id),t.vertexAttribPointer(this.attributes[s],4,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.attributes[s]),this}setFloat(t,s,i){return t.uniform1f(this.uniforms[s],i),this}setMat4(t,s,i){return t.uniformMatrix4fv(this.uniforms[s],!1,i.asFloat32Array()),this}setVec4(t,s,i){return t.uniform4fv(this.uniforms[s],new Float32Array(i)),this}drawTriangles(t,s,i=0){return t.drawArrays(t.TRIANGLES,i,s),this}drawTriangleStrip(t,s,i=0){return t.drawArrays(t.TRIANGLE_STRIP,i,s),this}}class r{setPositions(t){return this.positions=t,this}setNormals(t){return this.normals=t,this}setColors(t){return this.colors=t,this}}class n{constructor(t,s){this.id=t,this.count=s}static makePosition(t,s){return n.make(t,s)}static makeNormal(t,s){return n.make(t,s)}static makeColor(t,s){return n.make(t,s)}static make(t,s){let i=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,new Float32Array(s),t.STATIC_DRAW),new n(i,s.length)}}function h(t,s,i,e,o){const r=function(t,s,i,e,o){const r=t.x-e.x,n=t.y-e.y,h=t.z-e.z,a=s.x,l=s.y,d=s.z,c=o.x,m=o.y,u=o.z,p=2*m*m*a*r+2*m*m*d*h-2*m*c*a*n-2*m*c*l*r-2*m*u*l*h-2*m*u*d*n+2*c*c*l*n+2*c*c*d*h-2*c*u*a*h-2*c*u*d*r+2*u*u*a*r+2*u*u*l*n,w=m*m*a*a+m*m*d*d-2*m*c*a*l-2*m*u*l*d+c*c*l*l+c*c*d*d-2*c*u*a*d+u*u*a*a+u*u*l*l,f=p*p-4*w*(m*m*r*r+m*m*h*h-2*m*c*r*n-2*m*u*n*h+c*c*n*n+c*c*h*h-2*c*u*r*h+u*u*r*r+u*u*n*n-i*i);if(f<0)return 1/0;const g=Math.sqrt(f),y=2*w;if(0==y)return 1/0;const b=(-g-p)/y,v=(g-p)/y;return Math.min(b,v)}(t,s,i,e,o.normalized());if(!isFinite(r))return 1/0;const n=t.add(s.scale(r)),h=n.add(n.directionToLine(o,e)).sub(e).projectT(o);return h<0||h>1?1/0:r}function a(t,s,i,e){const o=t.x-e.x,r=t.y-e.y,n=t.z-e.z,h=s.x,a=s.y,l=s.z,d=i,c=2*(h*h+a*a+l*l);if(0==c)return 1/0;const m=Math.pow(2*h*o+2*a*r+2*l*n,2)-4*(h*h+a*a+l*l)*(-d*d+o*o+r*r+n*n);if(m<0)return 1/0;const u=1/c*(-Math.sqrt(m)-2*h*o-2*a*r-2*l*n),p=1/c*(Math.sqrt(m)-2*h*o-2*a*r-2*l*n);return Math.min(u,p)}const l=50;class d{constructor(){this.xMin=0,this.xMax=0,this.yMin=0,this.yMax=0,this.triangles=[],this.triangleBuckets=[];for(let t=0;t<l;t++){this.triangleBuckets.push([]);for(let s=0;s<l;s++)this.triangleBuckets[t].push([])}}addTri(s,i,e){const o=i.sub(s),r=e.sub(s),n=e.sub(i),h=s.sub(e),a=o.cross(h).normalized(),l=a.cross(o).normalized(),d=a.cross(n).normalized(),c=a.cross(h).normalized(),m=new t((s.x+i.x+e.x)/3,(s.y+i.y+e.y)/3,(s.z+i.z+e.z)/3),u=s.lerp(i,.5),p=i.lerp(e,.5),w=e.lerp(s,.5),f={index:this.triangles.length,v1:s,v2:i,v3:e,v1to2:o,v1to3:r,v2to3:n,v3to1:h,normal:a,v1to2Normal:l,v3to1Normal:c,v2to3Normal:d,centroid:m,v1to2Center:u,v3to1Center:w,v2to3Center:p};this.triangles.push(f),this.xMin=Math.min(this.xMin,s.x,i.x,e.x),this.xMax=Math.max(this.xMax,s.x,i.x,e.x),this.yMin=Math.min(this.yMin,s.y,i.y,e.y),this.yMax=Math.max(this.yMax,s.y,i.y,e.y)}build(){for(const t of this.triangles)this.addToNearBuckets(t,this.bucketForPosition(t.v1)),this.addToNearBuckets(t,this.bucketForPosition(t.v2)),this.addToNearBuckets(t,this.bucketForPosition(t.v3))}addToNearBuckets(t,s){this.addToBucket(t,s),this.addToBucket(t,{x:s.x-1,y:s.y}),this.addToBucket(t,{x:s.x+1,y:s.y}),this.addToBucket(t,{x:s.x-1,y:s.y-1}),this.addToBucket(t,{x:s.x+0,y:s.y-1}),this.addToBucket(t,{x:s.x+1,y:s.y-1}),this.addToBucket(t,{x:s.x-1,y:s.y+1}),this.addToBucket(t,{x:s.x+0,y:s.y+1}),this.addToBucket(t,{x:s.x+1,y:s.y+1})}addToBucket(t,s){if(s.x<0||s.x>=l)return;if(s.y<0||s.y>=l)return;const i=this.triangleBuckets[s.y][s.x];i.find((s=>s===t))||i.push(t)}bucketForPosition(t){return{x:Math.max(0,Math.floor((t.x-this.xMin)/(this.xMax-this.xMin)*l)%l),y:Math.max(0,Math.floor((t.y-this.yMin)/(this.yMax-this.yMin)*l)%l)}}*enumerateTrianglesByBuckets(t){const s=this.bucketForPosition(t);for(const t of this.triangleBuckets[s.y][s.x])yield t}repelAndSlide(t,s,i){let e=s,o=!1;for(let r=0;r<2;r++){const r=this.repel(t,s,i);if(t=r.position,!r.collided)break;o=!0,e=r.contact;const n=s.sub(r.position).projectOnPlane(r.position.sub(r.contact));s=t.add(n)}return{position:t,contact:e,collided:o}}collideAndSlide(t,s,i){let e=s,o=!1;for(let r=0;r<3;r++){const r=this.collide(t,s,i);if(t=r.position,!r.collided)break;o=!0,e=r.contact;const n=s.sub(r.position).projectOnPlane(r.position.sub(r.contact));s=t.add(n)}return{position:t,contact:e,collided:o}}repel(t,s,i){let e=s,o=1/0,r=s,n=!1;for(const h of this.enumerateTrianglesByBuckets(s)){const a=this.repelTriangle(h,t,s,i);if(!a)continue;const l=a.position.sub(t).projectT(s.sub(t));l<o&&(e=a.position,o=l,r=a.contact,n=!0)}return{position:e,contact:r,collided:n}}collide(t,s,i){let e=1,o=s;for(const r of this.triangles){const n=this.collideTriangle(r,t,s,i);n&&n.t<e&&(e=n.t,o=n.contact)}return{position:t.add(s.sub(t).scale(e)),contact:o,collided:e<1}}repelTriangle(t,s,i,e){const o=i.sub(s),r=o.normalized(),n=e*e;if(s.signedSqrDistanceToPlane(t.normal,t.v1)<=-n)return null;if(i.signedSqrDistanceToPlane(t.normal,t.v1)>=n)return null;const h=i.signedSqrDistanceToPlane(t.v1to2.normalized().cross(r),t.v1),a=i.signedSqrDistanceToPlane(t.v2to3.normalized().cross(r),t.v2),l=i.signedSqrDistanceToPlane(t.v3to1.normalized().cross(r),t.v3);if(h>=n||a>=n||l>=n)return null;const d=o,c=i.sub(d),m=this.collideTriangle(t,c,c.add(d),e);return m?{position:c.add(d.scale(m.t).withAddedMagn(.01*-e)),contact:m.contact}:null}collideTriangle(t,s,i,e){const o=t.normal.scale(e),r=i.sub(s);t.normal.dot(s.sub(o).sub(t.v1)),t.normal.dot(i.sub(o).sub(t.v1)),t.normal.dot(r);let n=function(t,s,i,e,o){const r=t.x,n=t.y,h=t.z,a=s.x,l=s.y,d=s.z,c=i,m=o.x,u=o.y,p=o.z,w=-e.dot(o),f=u*l+m*a+p*d;return 0==f?1/0:-(w+u*n+m*r+p*h-c)/f}(s,r,e,t.v1,t.normal);const l=s.sub(t.normal.scale(e)).add(r.scale(n)),d=l.sub(t.v1).dot(t.v1to2Normal),c=l.sub(t.v2).dot(t.v2to3Normal),m=l.sub(t.v3).dot(t.v3to1Normal);(d>0||c>0||m>0)&&(n=1/0);const u=h(s,r,e,t.v1,t.v1to2),p=h(s,r,e,t.v2,t.v2to3),w=h(s,r,e,t.v3,t.v3to1),f=a(s,r,e,t.v1),g=a(s,r,e,t.v2),y=a(s,r,e,t.v3),b=Math.min(n,u,p,w,f,g,y);if(b<0||b>1)return null;if(!isFinite(b))return null;if(n<u&&n<p&&n<w&&n<f&&n<g&&n<y)return{t:n,contact:l};if(u<p&&u<w&&u<f&&u<g&&u<y){const i=s.add(r.scale(u));return{t:u,contact:i.sub(i.directionToLine(t.v1to2,t.v1))}}if(p<w&&p<f&&p<g&&p<y){const i=s.add(r.scale(p));return{t:p,contact:i.sub(i.directionToLine(t.v2to3,t.v2))}}if(w<f&&w<g&&w<y){const i=s.add(r.scale(w));return{t:w,contact:i.sub(i.directionToLine(t.v3to1,t.v3))}}return f<g&&w<y?{t:f,contact:t.v1}:g<y?{t:g,contact:t.v2}:{t:y,contact:t.v3}}}class c{constructor(){this.positions=[],this.normals=[],this.colors=[]}addTri(s,i,e,o,r,n){return this.positions.push(s),this.positions.push(i),this.positions.push(e),this.normals.push(new t(0,0,0)),this.normals.push(new t(0,0,0)),this.normals.push(new t(0,0,0)),this.colors.push(o||[1,1,1,1]),this.colors.push(r||[1,1,1,1]),this.colors.push(n||[1,1,1,1]),this}addQuad(t,s,i,e,o,r,n,h){return this.addTri(t,s,i,o,r,n),this.addTri(t,i,e,o,n,h),this}addQuadSubdiv(t,s,i,e,o){for(let r=0;r<o;r++)for(let n=0;n<o;n++){let h=t.lerp(s,(n+0)/o),a=t.lerp(s,(n+1)/o),l=e.lerp(i,(n+1)/o),d=e.lerp(i,(n+0)/o),c=h.lerp(d,(r+0)/o),m=a.lerp(l,(r+0)/o),u=a.lerp(l,(r+1)/o),p=h.lerp(d,(r+1)/o);this.addQuad(c,m,u,p)}return this}addCube(s,i,e,o,r,n,h=1){let a=new t(s,i,e),l=new t(o,i,e),d=new t(o,r,e),c=new t(s,r,e),m=new t(s,i,n),u=new t(o,i,n),p=new t(o,r,n),w=new t(s,r,n);return this.addQuadSubdiv(a,l,d,c,h),this.addQuadSubdiv(m,w,p,u,h),this.addQuadSubdiv(l,a,m,u,h),this.addQuadSubdiv(d,l,u,p,h),this.addQuadSubdiv(c,d,p,w,h),this.addQuadSubdiv(a,c,w,m,h),this}addSphere(s,i,e,o,r,n,h=8){let a=this.positions.length;this.addCube(s,i,e,o,r,n,h);let l=new t((s+o)/2,(i+r)/2,(e+n)/2),d=new t(Math.abs(o-s)/2,Math.abs(r-i)/2,Math.abs(n-e)/2);for(let t=a;t<this.positions.length;t++)this.positions[t]=l.add(this.positions[t].sub(l).normalized().mul(d));return this}addCone(i,e,o,r,n,h,a=8,l){let d=this.positions.length,c=(i+r)/2,m=(e+n)/2,u=(r-i)/2,p=(n-e)/2;for(let s=0;s<a;s++){let i=(s+0)/a*Math.PI*2,e=(s+1)/a*Math.PI*2,r=Math.cos(i),n=Math.cos(e),l=Math.sin(i),d=Math.sin(e);this.addTri(new t(c+r*u,m+l*p,o),new t(c+n*u,m+d*p,o),new t(c,m,o)),this.addTri(new t(c+n*u,m+d*p,o),new t(c+r*u,m+l*p,o),new t(c,m,h))}if(null!=l){let i=s.rotationFromTo(new t(0,0,-1),l);for(let t=d;t<this.positions.length;t++)this.positions[t]=i.mulPoint(this.positions[t])}return this}addCylinder(i,e,o,r,n,h,a=8,l){let d=this.positions.length,c=(i+r)/2,m=(e+n)/2,u=(r-i)/2,p=(n-e)/2;for(let s=0;s<a;s++){let i=(s+0)/a*Math.PI*2,e=(s+1)/a*Math.PI*2,r=Math.cos(i),n=Math.cos(e),l=Math.sin(i),d=Math.sin(e);this.addTri(new t(c+r*u,m+l*p,o),new t(c+n*u,m+d*p,o),new t(c,m,o)),this.addTri(new t(c+n*u,m+d*p,h),new t(c+r*u,m+l*p,h),new t(c,m,h)),this.addQuad(new t(c+n*u,m+d*p,o),new t(c+r*u,m+l*p,o),new t(c+r*u,m+l*p,h),new t(c+n*u,m+d*p,h))}if(null!=l){let i=s.rotationFromTo(new t(0,0,-1),l);for(let t=d;t<this.positions.length;t++)this.positions[t]=i.mulPoint(this.positions[t])}return this}getMedianCenter(){if(0==this.positions.length)return{x:0,y:0,z:0};let t=[],s=[],i=[];for(let e of this.positions)t.push(e.x),s.push(e.y),i.push(e.z);return t.sort(((t,s)=>t-s)),s.sort(((t,s)=>t-s)),i.sort(((t,s)=>t-s)),{x:t[Math.floor(t.length/2)],y:s[Math.floor(t.length/2)],z:i[Math.floor(t.length/2)]}}makeDoubleSided(){let t=this.positions.length;for(let s=0;s<t;s+=3){let t=this.positions[s+0],i=this.positions[s+1],e=this.positions[s+2];this.addTri(t,e,i)}return this}calculateNormals(t=1.5){for(let t=0;t<this.positions.length;t+=3){let s=this.positions[t+0],i=this.positions[t+1],e=this.positions[t+2],o=i.sub(s),r=e.sub(s),n=o.cross(r).normalized();this.normals[t+0]=n,this.normals[t+1]=n,this.normals[t+2]=n}return this}makeModel(t){let s=[],i=[],e=[];for(let t=0;t<this.positions.length;t++)s.push(this.positions[t].x),s.push(this.positions[t].y),s.push(this.positions[t].z),i.push(this.normals[t].x),i.push(this.normals[t].y),i.push(this.normals[t].z),e.push(this.colors[t][0]),e.push(this.colors[t][1]),e.push(this.colors[t][2]),e.push(this.colors[t][3]);return(new r).setPositions(n.makePosition(t,s)).setNormals(n.makeNormal(t,i)).setColors(n.makeColor(t,e))}makeCollision(){let t=new d;for(let s=0;s<this.positions.length;s+=3)t.addTri(this.positions[s+0],this.positions[s+1],this.positions[s+2]);return t.build(),t}}class m{constructor(t){this.gl=t,this.matProjection=null,this.matView=null,this.matTransformStack=[s.identity()],this.modelPoint=(new c).addSphere(-.5,-.5,-.5,.5,.5,.5,4).calculateNormals().makeModel(t),this.modelPath=(new c).addCylinder(-.5,-.5,0,.5,.5,1,16).calculateNormals().makeModel(t),this.modelArrow=(new c).addCone(-.5,-.5,-1,.5,.5,0,16).calculateNormals().makeModel(t),this.material=o.makeFromSrc(t,u,p).registerLocations(t,["aPosition","aNormal"],["uMatProj","uMatView","uMatModel","uAmbientColor","uDiffuseColor"]),this.materialColor=o.makeFromSrc(t,w,f).registerLocations(t,["aPosition","aNormal","aColor"],["uMatProj","uMatView","uMatModel","uAmbientColor","uDiffuseColor","uFogDensity"]),this.materialUnshaded=o.makeFromSrc(t,u,g).registerLocations(t,["aPosition","aNormal"],["uMatProj","uMatView","uMatModel","uDiffuseColor"]),this.gl.enable(this.gl.DEPTH_TEST),this.gl.enable(this.gl.CULL_FACE),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.matrixCache=[],this.matrixCachePointer=0,this.matrixCacheUtilization=0,this.matrixCacheUtilizationTotal=0}begin(){this.matTransformStack.splice(1,this.matTransformStack.length),this.matrixCachePointer=0,this.matrixCacheUtilization=0,this.matrixCacheUtilizationTotal=0}viewport(t,s,i,e){this.gl.viewport(t,s,i,e)}clear(t=0,s=0,i=0,e=1,o=1){this.gl.clearColor(t,s,i,e),this.gl.clearDepth(o),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}clearDepth(t=1){this.gl.clearDepth(t),this.gl.clear(this.gl.DEPTH_BUFFER_BIT)}setProjection(t){this.matProjection=t;let s=[this.material,this.materialColor,this.materialUnshaded];for(const t of s)t.use(this.gl),t.setMat4(this.gl,"uMatProj",this.matProjection)}setView(t){this.matView=t;let s=[this.material,this.materialColor,this.materialUnshaded];for(const t of s)t.use(this.gl),t.setMat4(this.gl,"uMatView",this.matView),t.setVec4(this.gl,"uAmbientColor",[.5,.5,.5,1])}saveCache(t){this.matrixCachePointer<this.matrixCache.length?(this.matrixCache[this.matrixCachePointer]=t,this.matrixCachePointer++):(this.matrixCache.push(t),this.matrixCachePointer=this.matrixCache.length)}pushMatrix(t){this.matTransformStack.push(this.matTransformStack[this.matTransformStack.length-1].mul(t))}popMatrix(){this.matTransformStack.pop()}pushTranslationScale(t,i){this.matrixCacheUtilizationTotal++;const e=t.x,o=t.y,r=t.z,n=i.x,h=i.y,a=i.z;if(this.matrixCachePointer<this.matrixCache.length){let t=this.matrixCache[this.matrixCachePointer];if(t.x===e&&t.y===o&&t.z===r&&t.sx===n&&t.sy===h&&t.sz===a)return this.matTransformStack.push(t.matrix),this.matrixCachePointer++,void this.matrixCacheUtilization++}const l=this.matTransformStack[this.matTransformStack.length-1].mul(s.scale(n,h,a).mul(s.translation(e,o,r)));this.saveCache({x:e,y:o,z:r,sx:n,sy:h,sz:a,matrix:l}),this.matTransformStack.push(l)}popTranslationScale(){this.popMatrix()}drawModel(t,s,i){s.use(this.gl),s.bindPosition(this.gl,"aPosition",t.positions),s.bindNormals(this.gl,"aNormal",t.normals),s.hasColor&&s.bindColors(this.gl,"aColor",t.colors),s.setMat4(this.gl,"uMatModel",this.matTransformStack[this.matTransformStack.length-1]),s.setVec4(this.gl,"uDiffuseColor",i),s.drawTriangles(this.gl,t.positions.count/3)}drawArrow(i,e,o,r){this.matrixCacheUtilizationTotal++;let n=!1,h=null,a=null;if(this.matrixCachePointer<this.matrixCache.length){let t=this.matrixCache[this.matrixCachePointer];t.x1===i.x&&t.y1===i.y&&t.z1===i.z&&t.x2===e.x&&t.y2===e.y&&t.z2===e.z&&t.scale===o&&(h=t.matrixLine,a=t.matrixArrow,this.matrixCachePointer++,this.matrixCacheUtilization++,n=!0)}if(null===h||null===a){let r=s.scale(o,o,e.sub(i).magn()-2*o),n=s.rotationFromTo(new t(0,0,1),e.sub(i).normalized()),l=s.translation(i.x,i.y,i.z),d=s.scale(2*o,2*o,2*o),c=s.translation(e.x,e.y,e.z);h=this.matTransformStack[this.matTransformStack.length-1].mul(r.mul(n.mul(l))),a=this.matTransformStack[this.matTransformStack.length-1].mul(d.mul(n.mul(c)))}if(this.matTransformStack.push(h),this.drawModel(this.modelPath,this.material,r),this.matTransformStack.pop(),this.matTransformStack.push(a),this.drawModel(this.modelArrow,this.material,r),this.matTransformStack.pop(),!n){const t={x1:i.x,y1:i.y,z1:i.z,x2:e.x,y2:e.y,z2:e.z,scale:o,matrixLine:h,matrixArrow:a};this.saveCache(t)}}doStencilStampPass(t){this.gl.enable(this.gl.STENCIL_TEST),this.gl.stencilFunc(this.gl.ALWAYS,0,255),this.gl.stencilMask(255),this.gl.clearStencil(0),this.gl.clear(this.gl.STENCIL_BUFFER_BIT),this.gl.colorMask(!1,!1,!1,!1),this.gl.depthMask(!1),this.gl.cullFace(this.gl.FRONT),this.gl.stencilOp(this.gl.KEEP,this.gl.INCR,this.gl.KEEP),t(),this.gl.cullFace(this.gl.BACK),this.gl.stencilOp(this.gl.KEEP,this.gl.DECR,this.gl.KEEP),t(),this.gl.cullFace(this.gl.BACK),this.gl.colorMask(!0,!0,!0,!0),this.gl.stencilMask(0),this.gl.stencilFunc(this.gl.NOTEQUAL,0,255),t(),this.gl.depthMask(!0),this.gl.disable(this.gl.STENCIL_TEST)}}const u="\n\tprecision highp float;\n\t\n\tattribute vec4 aPosition;\n\tattribute vec4 aNormal;\n\n\tuniform mat4 uMatModel;\n\tuniform mat4 uMatView;\n\tuniform mat4 uMatProj;\n\t\n\tvarying vec4 vNormal;\n\tvarying vec4 vScreenNormal;\n\n\tvoid main()\n\t{\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\n\t\tvScreenNormal = uMatView * uMatModel * vec4(aNormal.xyz, 0);\n\t\t\n\t\tgl_Position = uMatProj * uMatView * uMatModel * aPosition;\n\t}",p="\n\tprecision highp float;\n\t\n\tvarying vec4 vNormal;\n\tvarying vec4 vScreenNormal;\n\t\n\tuniform vec4 uDiffuseColor;\n\tuniform vec4 uAmbientColor;\n\n\tvoid main()\n\t{\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\n\t\t\n\t\tvec4 ambientColor = uAmbientColor;\n\t\tvec4 diffuseColor = uDiffuseColor;\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\n\t\t\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\n\t\t\n\t\tgl_FragColor = diffuseColor * mix(ambientColor, lightColor, lightIncidence);\n\t}",w="\n\tprecision highp float;\n\t\n\tattribute vec4 aPosition;\n\tattribute vec4 aNormal;\n\tattribute vec4 aColor;\n\n\tuniform mat4 uMatModel;\n\tuniform mat4 uMatView;\n\tuniform mat4 uMatProj;\n\t\n\tvarying float vDepth;\n\tvarying vec4 vWorldPos;\n\tvarying vec4 vNormal;\n\tvarying vec4 vScreenNormal;\n\tvarying vec4 vColor;\n\n\tvoid main()\n\t{\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\n\t\tvScreenNormal = uMatModel * uMatView * vec4(aNormal.xyz, 0);\n\t\t\n\t\tvColor = aColor;\n\t\t\n\t\tvWorldPos = uMatModel * aPosition;\n\t\tvec4 position = uMatProj * uMatView * vWorldPos;\n\t\tgl_Position = position;\n\t\tvDepth = position.z / position.w;\n\t}",f="\n\tprecision highp float;\n\t\n\tvarying float vDepth;\n\tvarying vec4 vWorldPos;\n\tvarying vec4 vNormal;\n\tvarying vec4 vScreenNormal;\n\tvarying vec4 vColor;\n\t\n\tuniform vec4 uDiffuseColor;\n\tuniform vec4 uAmbientColor;\n\tuniform float uFogDensity;\n\n\tvoid main()\n\t{\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\n\t\t\n\t\tvec4 ambientColor = uAmbientColor;\n\t\tvec4 diffuseColor = uDiffuseColor * vColor;\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\n\t\t\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\n\t\t\n\t\tfloat patternFactor =\n\t\t\tmod(vWorldPos.x, 1.0) > 0.9 ||\n\t\t\tmod(vWorldPos.y, 1.0) > 0.9 ||\n\t\t\tmod(vWorldPos.z, 1.0) > 0.9 ? 0.0 : 1.0;\n\n\t\tgl_FragColor =\n\t\t\tmix(diffuseColor * vec4(0.85, 0.85, 0.85, 1), diffuseColor, patternFactor) *\n\t\t\tmix(ambientColor, lightColor, lightIncidence);\n\t}",g="\n\tprecision highp float;\n\t\n\tvarying vec4 vNormal;\n\tvarying vec4 vScreenNormal;\n\t\n\tuniform vec4 uDiffuseColor;\n\n\tvoid main()\n\t{\n\t\tgl_FragColor = uDiffuseColor;\n\t}";class y{constructor(){this.position=new t(0,0,0),this.scale=new t(1,1,1)}init(){}process(){}render(){}}class b extends y{init(){const s=new c;s.addQuad(new t(-10,-10,0),new t(10,-10,0),new t(10,10,0),new t(-10,10,0)),s.addCube(-5,-5,-1,-2,-2,1),s.addCube(-7,-5,-2,-5,-2,1),s.addQuad(new t(-2,-5,-1),new t(0,-5,0),new t(0,-2,0),new t(-2,-2,-1)),s.addTri(new t(0,-2,-.5),new t(2,-1,-.75),new t(1,2,-.5)),s.addTri(new t(2,-1,-.75),new t(2,2,-.25),new t(1,2,-.5)),s.calculateNormals(),this.model=s.makeModel(this.director.gl),this.collision=s.makeCollision()}render(){this.director.scene.pushTranslationScale(this.position,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[.1,.75,1,1]),this.director.scene.popTranslationScale();for(const t of this.collision.triangles)this.director.scene.drawArrow(t.centroid,t.centroid.add(t.normal.scale(.1)),.025,[1,0,0,1]),this.director.scene.drawArrow(t.v1,t.v1.add(t.normal.scale(.1)),.025,[0,0,1,1]),this.director.scene.drawArrow(t.v2,t.v2.add(t.normal.scale(.1)),.025,[0,1,0,1]),this.director.scene.drawArrow(t.v1to2Center,t.v1to2Center.add(t.v1to2Normal.scale(.1)),.025,[1,1,0,1]),this.director.scene.drawArrow(t.v2to3Center,t.v2to3Center.add(t.v2to3Normal.scale(.1)),.025,[1,1,0,1]),this.director.scene.drawArrow(t.v3to1Center,t.v3to1Center.add(t.v3to1Normal.scale(.1)),.025,[1,1,0,1])}}class v extends y{constructor(){super(...arguments),this.posPrev=new t(0,0,0),this.speed=new t(0,0,0),this.radius=.15,this.collisionPos=new t(0,0,0)}init(){const t=new c;t.addSphere(-this.radius,-this.radius,-this.radius,this.radius,this.radius,this.radius),t.calculateNormals(),this.model=t.makeModel(this.director.gl),this.posPrev=this.position}process(){this.handleMovement(),this.handleJump(),this.handleCollision(),this.posPrev=this.position}handleMovement(){const s=this.director.objectFind(k);if(!s)return;const i=s.lookAt.sub(s.position).withZ(0).normalized(),e=new t(i.y,-i.x,0);let o=new t(0,0,0);(this.director.keysHeld.has("arrowup")||this.director.keysHeld.has("w"))&&(o.y+=1),(this.director.keysHeld.has("arrowdown")||this.director.keysHeld.has("s"))&&(o.y-=1),(this.director.keysHeld.has("arrowleft")||this.director.keysHeld.has("a"))&&(o.x-=1),(this.director.keysHeld.has("arrowright")||this.director.keysHeld.has("d"))&&(o.x+=1),o=o.normalized().scale(.005);let r=this.speed.withZ(0);r=r.add(i.scale(o.y)).add(e.scale(o.x));const n=r.withZ(0).magn();n>.05&&(r=r.withZ(0).normalized().scale(.05)),0==o.magn()&&(r=n>.015?r.sub(r.normalized().scale(.015)):new t(0,0,r.z)),this.speed=this.speed.sub(this.speed.withZ(0)).add(r)}handleJump(){this.speed=this.speed.add(new t(0,0,.01)),this.director.keysDown.has(" ")&&(this.speed=this.speed.withZ(-.15))}handleCollision(){const s=this.director.objectFind(b);if(!s)return;this.collisionPos=this.position;const i=s.collision.repel(this.position,this.position.add(new t(0,0,this.speed.z)),this.radius);this.position=i.position,this.position.z<=this.posPrev.z&&this.speed.z>0&&(this.speed=this.speed.withZ(0));const e=s.collision.repelAndSlide(this.position,this.position.add(this.speed.withZ(0)),this.radius);this.position=e.position}render(){this.director.scene.pushTranslationScale(this.position,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,1,1,1]),this.director.scene.popTranslationScale()}}class x extends y{constructor(){super(...arguments),this.position2=new t(0,0,0),this.speed=new t(0,0,0),this.speed2=new t(0,0,0),this.radius=.15}init(){const s=new c;s.addSphere(-this.radius,-this.radius,-this.radius,this.radius,this.radius,this.radius),s.calculateNormals(),this.model=s.makeModel(this.director.gl),this.position2=this.position.add(new t(0,0,1))}process(){this.handleMovement1(),this.handleMovement2(),this.position=this.position.add(this.speed),this.position2=this.position2.add(this.speed),this.position2=this.position2.add(this.speed2)}handleMovement1(){const s=this.director.objectFind(k);if(!s)return;const i=s.lookAt.sub(s.position).withZ(0).normalized(),e=new t(i.y,-i.x,0),o=new t(0,0,-1);let r=new t(0,0,0);this.director.keysHeld.has("z")||((this.director.keysHeld.has("arrowup")||this.director.keysHeld.has("w"))&&(r.y+=1),(this.director.keysHeld.has("arrowdown")||this.director.keysHeld.has("s"))&&(r.y-=1),(this.director.keysHeld.has("arrowleft")||this.director.keysHeld.has("a"))&&(r.x-=1),(this.director.keysHeld.has("arrowright")||this.director.keysHeld.has("d"))&&(r.x+=1),this.director.keysHeld.has("q")&&(r.z-=1),this.director.keysHeld.has("e")&&(r.z+=1)),r=r.normalized().scale(.005),this.speed=this.speed.add(i.scale(r.y)).add(e.scale(r.x)).add(o.scale(r.z));const n=this.speed.magn();n>.05&&(this.speed=this.speed.normalized().scale(.05)),0==r.magn()&&(this.speed=n>.015?this.speed.sub(this.speed.normalized().scale(.015)):new t(0,0,0))}handleMovement2(){const s=this.director.objectFind(k);if(!s)return;const i=s.lookAt.sub(s.position).withZ(0).normalized(),e=new t(i.y,-i.x,0),o=new t(0,0,-1);let r=new t(0,0,0);this.director.keysHeld.has("z")&&((this.director.keysHeld.has("arrowup")||this.director.keysHeld.has("w"))&&(r.y+=1),(this.director.keysHeld.has("arrowdown")||this.director.keysHeld.has("s"))&&(r.y-=1),(this.director.keysHeld.has("arrowleft")||this.director.keysHeld.has("a"))&&(r.x-=1),(this.director.keysHeld.has("arrowright")||this.director.keysHeld.has("d"))&&(r.x+=1),this.director.keysHeld.has("q")&&(r.z-=1),this.director.keysHeld.has("e")&&(r.z+=1)),r=r.normalized().scale(.005),this.speed2=this.speed2.add(i.scale(r.y)).add(e.scale(r.x)).add(o.scale(r.z));const n=this.speed2.magn();n>.05&&(this.speed2=this.speed2.normalized().scale(.05)),0==r.magn()&&(this.speed2=n>.015?this.speed2.sub(this.speed2.normalized().scale(.015)):new t(0,0,0))}render(){const s=this.director.objectFind(b);if(!s)return;const i=this.position,e=this.position2,o=s.collision.repel(i,e,this.radius),r=s.collision.repelAndSlide(i,e,this.radius);this.director.scene.pushTranslationScale(i,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,0,0,1]),this.director.scene.popTranslationScale(),this.director.scene.pushTranslationScale(o.position,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,.5,0,1]),this.director.scene.popTranslationScale(),this.director.scene.pushTranslationScale(r.position,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,1,0,1]),this.director.scene.popTranslationScale(),this.director.scene.pushTranslationScale(o.contact,new t(.25,.25,.25)),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,0,0,1]),this.director.scene.popTranslationScale(),this.director.scene.drawArrow(i,e,.025,[1,0,0,1]),this.director.scene.drawArrow(i,r.position,.025,[1,.5,1,1]),this.director.scene.drawArrow(i,r.position,.025,[1,1,0,1]),this.director.scene.drawArrow(o.position,r.position,.025,[1,1,1,1]),this.director.scene.drawArrow(o.position,o.position.add(o.position.sub(o.contact).scale(2*this.scale.x)),.025,[1,0,0,1])}}class k extends y{constructor(){super(...arguments),this.lookAt=new t(0,0,0),this.up=new t(0,0,-1)}init(){const t=new c;t.addCube(-1,-1,-1,1,1,1),t.calculateNormals(),this.model=t.makeModel(this.director.gl)}setMatrices(){this.director.scene.setProjection(s.perspective(60,this.director.canvasW/this.director.canvasH,.1,1e4)),this.director.scene.setView(s.lookat(this.position,this.lookAt,this.up))}process(){let s=this.director.objectFind(S);if(s||(s=this.director.objectFind(v)),s||(s=this.director.objectFind(x)),s)if(s instanceof S)this.lookAt=s.center.add(new t(0,0,-.5)),this.position=s.center.sub(s.forward.withZ(0).normalized().scale(5)).add(new t(0,0,-1.5));else{this.lookAt=s.position;const i=5,e=this.lookAt.sub(this.position).normalized().withZ(0).scale(i),o=this.lookAt.sub(e).add(new t(0,0,.5-.45*i));this.position=o}}}class M{constructor(){this.id=0,this.pos=new t(0,0,0),this.posPrev=new t(0,0,0),this.speed=new t(0,0,0),this.instantSpeed=new t(0,0,0),this.radius=.15,this.touchingGround=!1}init(t){this.director=t;const s=new c;s.addSphere(-1,-1,-1,1,1,1),s.calculateNormals(),this.model=s.makeModel(this.director.gl)}processGravity(){this.speed=this.speed.add(new t(0,0,.0025))}processCollision(s){this.touchingGround=!1,this.posPrev=this.pos;const i=this.pos.add(new t(0,0,this.speed.z)),e=s.repel(this.pos,i,this.radius);this.pos=e.position;const o=s.repelAndSlide(this.pos,this.pos.add(this.speed.withZ(0)),this.radius);if(this.pos=o.position,this.speed=this.pos.sub(this.posPrev),0!=this.instantSpeed.magn()){const t=s.repel(this.pos,this.pos.add(this.instantSpeed),this.radius);this.pos=t.position}this.instantSpeed=new t(0,0,0),s.repel(this.pos,this.pos.add(new t(0,0,this.radius+.1)),this.radius).position.z<=this.pos.z+.1&&(this.touchingGround=!0)}render(){this.director.scene.pushTranslationScale(this.pos,new t(this.radius,this.radius,this.radius)),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[1,1,this.touchingGround?1:0,1]),this.director.scene.popTranslationScale()}}class z extends y{init(){}setModel(t,s){this.model=s.makeModel(t),this.collision=s.makeCollision(),console.log(this.collision.triangles)}render(){this.director.scene.pushTranslationScale(this.position,this.scale),this.director.scene.drawModel(this.model,this.director.scene.materialColor,[.1,.75,1,1]),this.director.scene.popTranslationScale()}}function C(t,s,i){return t<s?Math.min(t+i,s):Math.max(t-i,s)}class S extends y{constructor(){super(...arguments),this.engineSpeed=0,this.steerSpeed=0}init(){this.bodies=[new M,new M,new M,new M];for(const t of this.bodies)t.init(this.director);this.joints=[],this.reset()}reset(){const s=Math.sqrt(.3125),i=.15,e=new t(50,50,-15);this.bodies[0].id=0,this.bodies[1].id=1,this.bodies[2].id=2,this.bodies[3].id=3,this.bodies[0].pos=e.add(new t(1,0,0)),this.bodies[1].pos=e.add(new t(1,1,0)),this.bodies[2].pos=e.add(new t(0,1,0)),this.bodies[3].pos=e.add(new t(0,0,0)),this.bodies[0].speed=new t(0,0,0),this.bodies[1].speed=new t(0,0,0),this.bodies[2].speed=new t(0,0,0),this.bodies[3].speed=new t(0,0,0),this.bodies[0].radius=i,this.bodies[1].radius=i,this.bodies[2].radius=i,this.bodies[3].radius=i,this.joints=[{body1:this.bodies[0],body2:this.bodies[1],length:.25,tensionK:.1,frictionK:.1},{body1:this.bodies[2],body2:this.bodies[3],length:.25,tensionK:.1,frictionK:.1},{body1:this.bodies[0],body2:this.bodies[3],length:.5,tensionK:.1,frictionK:.1},{body1:this.bodies[1],body2:this.bodies[2],length:.5,tensionK:.1,frictionK:.1},{body1:this.bodies[0],body2:this.bodies[2],length:s,tensionK:.25,frictionK:.1},{body1:this.bodies[1],body2:this.bodies[3],length:s,tensionK:.25,frictionK:.1}]}process(){this.handleVectors(),this.handleMovement(),this.handleJoints();const t=this.director.objectFind(z);if(t)for(const s of this.bodies)s.processGravity(),s.processCollision(t.collision)}handleVectors(){this.centerPrev=this.center??new t(0,0,0),this.center=new t(0,0,0);for(const t of this.bodies)this.center=this.center.add(t.pos);this.center=this.center.scale(1/this.bodies.length),this.position=this.center,this.speed=this.center.sub(this.centerPrev),this.nose=this.bodies[0].pos.add(this.bodies[1].pos).scale(.5),this.forward=this.nose.sub(this.center).normalized(),this.up=this.forward.cross(this.bodies[0].pos.sub(this.bodies[1].pos)).normalized(),this.up.z>0&&(this.up=this.up.neg()),this.right=this.up.cross(this.forward)}handleMovement(){if(!this.director.objectFind(k))return;const t=.0025;this.director.keysHeld.has("arrowup")||this.director.keysHeld.has("w")||this.director.keysHeld.has(" ")?this.engineSpeed=C(this.engineSpeed,1,1):this.director.keysHeld.has("arrowdown")||this.director.keysHeld.has("s")||this.director.keysHeld.has("x")?this.engineSpeed=C(this.engineSpeed,-1,1):this.engineSpeed=0,this.director.keysHeld.has("arrowleft")||this.director.keysHeld.has("a")?this.steerSpeed=C(this.steerSpeed,-.02,t):this.director.keysHeld.has("arrowright")||this.director.keysHeld.has("d")?this.steerSpeed=C(this.steerSpeed,.02,t):this.steerSpeed=C(this.steerSpeed,0,.005);for(const t of this.bodies){if(!t.touchingGround)continue;const s=this.forward.scale(.22*this.engineSpeed).sub(t.speed).scale(.015);t.speed=t.speed.add(s);const i=t.speed.project(this.right);t.speed=t.speed.sub(i.scale(.25))}const i=s.rotation(this.up,this.steerSpeed);for(const t of this.bodies){const s=t.pos.sub(this.center),e=i.mulPoint(s);t.instantSpeed=t.instantSpeed.add(e.sub(s))}}handleJoints(){for(const t of this.joints){const s=t.body1.pos.sub(t.body2.pos),i=s.normalized(),e=s.magn(),o=i.scale((e-t.length)*t.tensionK);t.body1.speed=t.body1.speed.sub(o),t.body2.speed=t.body2.speed.add(o);const r=t.body1.speed.sub(t.body2.speed).scale(t.frictionK);t.body1.speed=t.body1.speed.sub(r),t.body2.speed=t.body2.speed.add(r)}}render(){for(const t of this.bodies)t.render();this.director.scene.drawArrow(this.center,this.center.add(this.up.withMagn(100)),.025,[0,1,0,1]),this.director.scene.drawArrow(this.center,this.center.add(this.bodies[0].speed.scale(100)),.025,[1,1,0,1]),this.director.scene.drawArrow(this.center,this.center.add(this.bodies[0].speed.project(this.right).scale(100)),.025,[1,0,1,1])}}class T{static load(s){let i=new TextDecoder("utf-8").decode(s).replace("\r\n","\n").split("\n").map((t=>t.trim())),e=[],o=null,r=null;for(let s of i){if(s.startsWith("#"))continue;let i=s.match(/^o[ ]+(.*)/);if(null!=i){let t={};t.name=i[1],t.vertices=[],t.normals=[],t.texCoords=[],t.geometries=[],e.push(t),o=t;continue}if(null==o){let t={name:"Default Object",vertices:[],normals:[],texCoords:[],geometries:[]};e.push(t),o=t}let n=s.match(/^v[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);if(null!=n){let s=new t(parseFloat(n[1]),-parseFloat(n[3]),-parseFloat(n[2]));o.vertices.push(s);continue}let h=s.match(/^vt[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);if(null!=h){let s=new t(parseFloat(h[1]),parseFloat(h[2]),0);o.texCoords.push(s);continue}let a=s.match(/^vn[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);if(null!=a){let s=new t(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]));o.normals.push(s);continue}let l=s.match(/^g[ ]+(.*)/);if(null==l){if(null!=r&&s.startsWith("f")){let i=s.substr(1).split(" ").map((t=>t.trim())),e=[];for(let s of i){if(""==s)continue;let i=s.split("/"),r={};r.position=o.vertices[parseInt(i[0])-1],r.texCoord=i.length<2?new t(0,0,0):o.texCoords[parseInt(i[1])-1],r.normal=i.length<3?new t(0,0,0):o.normals[parseInt(i[2])-1],r.position&&e.push(r)}r.faces.push(e)}}else{let t={};t.name=l[1],t.faces=[],o.geometries.push(t),r=t}}return e}static makeModelBuilder(t){let s=T.load(t);console.log(s);let i=new c;for(let t of s)for(let s of t.geometries)for(let t of s.faces)t.length>=3&&(i.addTri(t[0].position,t[1].position,t[2].position),i.addTri(t[0].position,t[2].position,t[1].position));return i.calculateNormals()}}class P{constructor(){this.canvas=document.getElementById("canvasMain"),this.canvasW=this.canvasH=0,this.resize(),this.gl=this.canvas.getContext("webgl",{stencil:!0}),this.scene=new m(this.gl),this.keysDown=new Set,this.keysHeld=new Set,this.keysHeldPrev=new Set,this.objects=[],this.init()}resize(){const t=this.canvas.getBoundingClientRect();this.canvasW=t.width,this.canvasH=t.height,this.canvas.width=t.width,this.canvas.height=t.height}async init(){const s=await fetch("assets/track.obj").then((t=>t.arrayBuffer())),i=T.makeModelBuilder(s);this.objects=[];const e=new S;this.objectAdd(e);const o=new k;o.position=new t(2,4,-4),this.objectAdd(o);const r=new z;r.setModel(this.gl,i),this.objectAdd(r),(new x).position=new t(0,0,-1.25)}objectAdd(t){t.director=this,t.init(),this.objects.push(t)}objectDestroy(t){this.objects=this.objects.filter((s=>s!==t))}objectFind(t){for(const s of this.objects)if(s instanceof t)return s;return null}objectWith(t,s){for(const i of this.objects)i instanceof t&&s(i)}process(){this.keysDown.clear();for(const t of this.keysHeld)this.keysHeldPrev.has(t)||this.keysDown.add(t);if(this.keysDown.has("t")){const s=this.objectFind(S),i=this.objectFind(v),e=this.objectFind(x);if(s){this.objectDestroy(s);const i=new v;i.position=new t(0,0,-1.25),this.objectAdd(i)}else if(i){this.objectDestroy(i);const s=new x;s.position=new t(0,0,-1.25),this.objectAdd(s)}else if(e){this.objectDestroy(e);const t=new S;this.objectAdd(t)}}for(const t of this.objects)t.process();this.keysHeldPrev.clear();for(const t of this.keysHeld)this.keysHeldPrev.add(t)}render(){this.scene.begin(),this.scene.viewport(0,0,this.canvasW,this.canvasH),this.scene.clear(0,0,0,1,1),this.objectWith(k,(t=>t.setMatrices()));for(const t of this.objects)t.render()}}function A(t){t(),window.requestAnimationFrame((()=>A(t)))}!function(){const t=new P;window.addEventListener("keydown",(s=>{t.keysHeld.add(s.key.toLowerCase())})),window.addEventListener("keyup",(s=>{t.keysHeld.delete(s.key.toLowerCase())})),A((()=>{t.process(),t.render()}))}()})();