/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/director.ts":
/*!*************************!*\
  !*** ./src/director.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Director\": () => (/* binding */ Director)\n/* harmony export */ });\n/* harmony import */ var _gl_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl/scene */ \"./src/gl/scene.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _objects_kart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objects/kart */ \"./src/objects/kart.ts\");\n/* harmony import */ var _objects_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./objects/player */ \"./src/objects/player.ts\");\n/* harmony import */ var _objects_camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./objects/camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _objects_test__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./objects/test */ \"./src/objects/test.ts\");\n/* harmony import */ var _util_objLoader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/objLoader */ \"./src/util/objLoader.ts\");\n/* harmony import */ var _objects_stage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects/stage */ \"./src/objects/stage.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Director {\r\n    constructor() {\r\n        this.canvas = document.getElementById(\"canvasMain\");\r\n        this.canvasW = this.canvasH = 0;\r\n        this.resize();\r\n        this.gl = this.canvas.getContext(\"webgl\", { stencil: true });\r\n        this.scene = new _gl_scene__WEBPACK_IMPORTED_MODULE_0__.Scene(this.gl);\r\n        this.keysDown = new Set();\r\n        this.keysHeld = new Set();\r\n        this.keysHeldPrev = new Set();\r\n        this.objects = [];\r\n        this.init();\r\n    }\r\n    resize() {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        this.canvasW = rect.width;\r\n        this.canvasH = rect.height;\r\n        this.canvas.width = rect.width;\r\n        this.canvas.height = rect.height;\r\n    }\r\n    async init() {\r\n        const trackFile = await fetch(\"assets/track.obj\").then(t => t.arrayBuffer());\r\n        const trackModel = _util_objLoader__WEBPACK_IMPORTED_MODULE_6__.ObjLoader.makeModelBuilder(trackFile);\r\n        this.objects = [];\r\n        const player = new _objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart();\r\n        this.objectAdd(player);\r\n        const camera = new _objects_camera__WEBPACK_IMPORTED_MODULE_4__.Camera();\r\n        camera.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(2, 4, -4);\r\n        this.objectAdd(camera);\r\n        const stage = new _objects_stage__WEBPACK_IMPORTED_MODULE_7__.Stage();\r\n        stage.setModel(this.gl, trackModel);\r\n        this.objectAdd(stage);\r\n        const test = new _objects_test__WEBPACK_IMPORTED_MODULE_5__.Test();\r\n        test.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, -1.25);\r\n        //this.objectAdd(test)\r\n    }\r\n    objectAdd(object) {\r\n        object.director = this;\r\n        object.init();\r\n        this.objects.push(object);\r\n    }\r\n    objectDestroy(object) {\r\n        this.objects = this.objects.filter(obj => obj !== object);\r\n    }\r\n    objectFind(typ) {\r\n        for (const object of this.objects) {\r\n            if (object instanceof typ)\r\n                return object;\r\n        }\r\n        return null;\r\n    }\r\n    objectWith(typ, fn) {\r\n        for (const object of this.objects) {\r\n            if (object instanceof typ) {\r\n                fn(object);\r\n            }\r\n        }\r\n    }\r\n    process() {\r\n        this.keysDown.clear();\r\n        for (const key of this.keysHeld) {\r\n            if (!this.keysHeldPrev.has(key))\r\n                this.keysDown.add(key);\r\n        }\r\n        if (this.keysDown.has(\"t\")) {\r\n            const kart = this.objectFind(_objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart);\r\n            const player = this.objectFind(_objects_player__WEBPACK_IMPORTED_MODULE_3__.Player);\r\n            const test = this.objectFind(_objects_test__WEBPACK_IMPORTED_MODULE_5__.Test);\r\n            if (kart) {\r\n                this.objectDestroy(kart);\r\n                const newPlayer = new _objects_player__WEBPACK_IMPORTED_MODULE_3__.Player();\r\n                newPlayer.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, -1.25);\r\n                this.objectAdd(newPlayer);\r\n            }\r\n            else if (player) {\r\n                this.objectDestroy(player);\r\n                const newTest = new _objects_test__WEBPACK_IMPORTED_MODULE_5__.Test();\r\n                newTest.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, -1.25);\r\n                this.objectAdd(newTest);\r\n            }\r\n            else if (test) {\r\n                this.objectDestroy(test);\r\n                const newKart = new _objects_kart__WEBPACK_IMPORTED_MODULE_2__.Kart();\r\n                this.objectAdd(newKart);\r\n            }\r\n        }\r\n        for (const object of this.objects)\r\n            object.process();\r\n        this.keysHeldPrev.clear();\r\n        for (const key of this.keysHeld)\r\n            this.keysHeldPrev.add(key);\r\n    }\r\n    render() {\r\n        this.scene.begin();\r\n        this.scene.viewport(0, 0, this.canvasW, this.canvasH);\r\n        this.scene.clear(0, 0, 0, 1, 1);\r\n        this.objectWith(_objects_camera__WEBPACK_IMPORTED_MODULE_4__.Camera, (c) => c.setMatrices());\r\n        for (const object of this.objects)\r\n            object.render();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/director.ts?");

/***/ }),

/***/ "./src/gl/buffer.ts":
/*!**************************!*\
  !*** ./src/gl/buffer.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLBuffer\": () => (/* binding */ GLBuffer)\n/* harmony export */ });\nclass GLBuffer {\r\n    constructor(id, count) {\r\n        this.id = id;\r\n        this.count = count;\r\n    }\r\n    static makePosition(gl, positions) {\r\n        return GLBuffer.make(gl, positions);\r\n    }\r\n    static makeNormal(gl, normals) {\r\n        return GLBuffer.make(gl, normals);\r\n    }\r\n    static makeColor(gl, colors) {\r\n        return GLBuffer.make(gl, colors);\r\n    }\r\n    static make(gl, data) {\r\n        let buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\r\n        return new GLBuffer(buffer, data.length);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/gl/buffer.ts?");

/***/ }),

/***/ "./src/gl/model.ts":
/*!*************************!*\
  !*** ./src/gl/model.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GfxModel)\n/* harmony export */ });\nclass GfxModel {\r\n    setPositions(positions) {\r\n        this.positions = positions;\r\n        return this;\r\n    }\r\n    setNormals(normals) {\r\n        this.normals = normals;\r\n        return this;\r\n    }\r\n    setColors(colors) {\r\n        this.colors = colors;\r\n        return this;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/gl/model.ts?");

/***/ }),

/***/ "./src/gl/scene.ts":
/*!*************************!*\
  !*** ./src/gl/scene.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader */ \"./src/gl/shader.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n\r\n\r\n\r\n\r\nclass Scene {\r\n    constructor(gl) {\r\n        this.gl = gl;\r\n        this.matProjection = null;\r\n        this.matView = null;\r\n        this.matTransformStack = [_math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.identity()];\r\n        this.modelPoint = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.default()\r\n            .addSphere(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 4)\r\n            .calculateNormals()\r\n            .makeModel(gl);\r\n        this.modelPath = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.default()\r\n            .addCylinder(-0.5, -0.5, 0, 0.5, 0.5, 1, 16)\r\n            .calculateNormals()\r\n            .makeModel(gl);\r\n        this.modelArrow = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.default()\r\n            .addCone(-0.5, -0.5, -1, 0.5, 0.5, 0, 16)\r\n            .calculateNormals()\r\n            .makeModel(gl);\r\n        this.material = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrc, fragmentSrc)\r\n            .registerLocations(gl, [\"aPosition\", \"aNormal\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uAmbientColor\", \"uDiffuseColor\"]);\r\n        this.materialColor = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrcColor, fragmentSrcColor)\r\n            .registerLocations(gl, [\"aPosition\", \"aNormal\", \"aColor\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uAmbientColor\", \"uDiffuseColor\", \"uFogDensity\"]);\r\n        this.materialUnshaded = _shader__WEBPACK_IMPORTED_MODULE_2__.GLProgram.makeFromSrc(gl, vertexSrc, fragmentSrcUnshaded)\r\n            .registerLocations(gl, [\"aPosition\", \"aNormal\"], [\"uMatProj\", \"uMatView\", \"uMatModel\", \"uDiffuseColor\"]);\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        this.gl.enable(this.gl.CULL_FACE);\r\n        this.gl.depthFunc(this.gl.LEQUAL);\r\n        this.gl.enable(this.gl.BLEND);\r\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\r\n        this.matrixCache = [];\r\n        this.matrixCachePointer = 0;\r\n        this.matrixCacheUtilization = 0;\r\n        this.matrixCacheUtilizationTotal = 0;\r\n    }\r\n    begin() {\r\n        //if (this.matrixCacheUtilization < this.matrixCacheUtilizationTotal)\r\n        //\tconsole.log(\"last frame cache utilization: \" + this.matrixCacheUtilization + \" / \" + this.matrixCacheUtilizationTotal)\r\n        this.matTransformStack.splice(1, this.matTransformStack.length);\r\n        this.matrixCachePointer = 0;\r\n        this.matrixCacheUtilization = 0;\r\n        this.matrixCacheUtilizationTotal = 0;\r\n    }\r\n    viewport(x, y, w, h) {\r\n        this.gl.viewport(x, y, w, h);\r\n    }\r\n    clear(r = 0, g = 0, b = 0, a = 1, depth = 1) {\r\n        this.gl.clearColor(r, g, b, a);\r\n        this.gl.clearDepth(depth);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    clearDepth(depth = 1) {\r\n        this.gl.clearDepth(depth);\r\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    setProjection(matrix) {\r\n        this.matProjection = matrix;\r\n        let materials = [\r\n            this.material,\r\n            this.materialColor,\r\n            this.materialUnshaded,\r\n        ];\r\n        for (const mat of materials) {\r\n            mat.use(this.gl);\r\n            mat.setMat4(this.gl, \"uMatProj\", this.matProjection);\r\n        }\r\n    }\r\n    setView(matrix) {\r\n        this.matView = matrix;\r\n        let materials = [\r\n            this.material,\r\n            this.materialColor,\r\n            this.materialUnshaded,\r\n        ];\r\n        for (const mat of materials) {\r\n            mat.use(this.gl);\r\n            mat.setMat4(this.gl, \"uMatView\", this.matView);\r\n            mat.setVec4(this.gl, \"uAmbientColor\", [0.5, 0.5, 0.5, 1]);\r\n        }\r\n    }\r\n    saveCache(newCache) {\r\n        if (this.matrixCachePointer < this.matrixCache.length) {\r\n            this.matrixCache[this.matrixCachePointer] = newCache;\r\n            this.matrixCachePointer++;\r\n        }\r\n        else {\r\n            this.matrixCache.push(newCache);\r\n            this.matrixCachePointer = this.matrixCache.length;\r\n        }\r\n    }\r\n    pushMatrix(matrix) {\r\n        this.matTransformStack.push(this.matTransformStack[this.matTransformStack.length - 1].mul(matrix));\r\n    }\r\n    popMatrix() {\r\n        this.matTransformStack.pop();\r\n    }\r\n    pushTranslationScale(pos, scale) {\r\n        this.matrixCacheUtilizationTotal++;\r\n        const x = pos.x;\r\n        const y = pos.y;\r\n        const z = pos.z;\r\n        const sx = scale.x;\r\n        const sy = scale.y;\r\n        const sz = scale.z;\r\n        if (this.matrixCachePointer < this.matrixCache.length) {\r\n            let cache = this.matrixCache[this.matrixCachePointer];\r\n            if (cache.x === x && cache.y === y && cache.z === z &&\r\n                cache.sx === sx && cache.sy === sy && cache.sz === sz) {\r\n                this.matTransformStack.push(cache.matrix);\r\n                this.matrixCachePointer++;\r\n                this.matrixCacheUtilization++;\r\n                return;\r\n            }\r\n        }\r\n        const matrix = this.matTransformStack[this.matTransformStack.length - 1]\r\n            .mul(_math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.scale(sx, sy, sz).mul(_math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.translation(x, y, z)));\r\n        this.saveCache({ x, y, z, sx, sy, sz, matrix });\r\n        this.matTransformStack.push(matrix);\r\n    }\r\n    popTranslationScale() {\r\n        this.popMatrix();\r\n    }\r\n    drawModel(model, material, diffuseColor) {\r\n        material.use(this.gl);\r\n        material.bindPosition(this.gl, \"aPosition\", model.positions);\r\n        material.bindNormals(this.gl, \"aNormal\", model.normals);\r\n        if (material.hasColor)\r\n            material.bindColors(this.gl, \"aColor\", model.colors);\r\n        material.setMat4(this.gl, \"uMatModel\", this.matTransformStack[this.matTransformStack.length - 1]);\r\n        material.setVec4(this.gl, \"uDiffuseColor\", diffuseColor);\r\n        material.drawTriangles(this.gl, model.positions.count / 3);\r\n    }\r\n    drawArrow(pos1, pos2, scale, color) {\r\n        this.matrixCacheUtilizationTotal++;\r\n        let hadCache = false;\r\n        let matrixLine = null;\r\n        let matrixArrow = null;\r\n        if (this.matrixCachePointer < this.matrixCache.length) {\r\n            let cache = this.matrixCache[this.matrixCachePointer];\r\n            if (cache.x1 === pos1.x && cache.y1 === pos1.y && cache.z1 === pos1.z &&\r\n                cache.x2 === pos2.x && cache.y2 === pos2.y && cache.z2 === pos2.z &&\r\n                cache.scale === scale) {\r\n                matrixLine = cache.matrixLine;\r\n                matrixArrow = cache.matrixArrow;\r\n                this.matrixCachePointer++;\r\n                this.matrixCacheUtilization++;\r\n                hadCache = true;\r\n            }\r\n        }\r\n        if (matrixLine === null || matrixArrow === null) {\r\n            let matrixScale = _math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.scale(scale, scale, pos2.sub(pos1).magn() - scale * 2);\r\n            let matrixAlign = _math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 1), pos2.sub(pos1).normalized());\r\n            let matrixTranslate = _math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.translation(pos1.x, pos1.y, pos1.z);\r\n            let matrixScaleArrow = _math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.scale(scale * 2, scale * 2, scale * 2);\r\n            let matrixTranslateArrow = _math_mat4__WEBPACK_IMPORTED_MODULE_0__.default.translation(pos2.x, pos2.y, pos2.z);\r\n            matrixLine = this.matTransformStack[this.matTransformStack.length - 1]\r\n                .mul(matrixScale.mul(matrixAlign.mul(matrixTranslate)));\r\n            matrixArrow = this.matTransformStack[this.matTransformStack.length - 1]\r\n                .mul(matrixScaleArrow.mul(matrixAlign.mul(matrixTranslateArrow)));\r\n        }\r\n        this.matTransformStack.push(matrixLine);\r\n        this.drawModel(this.modelPath, this.material, color);\r\n        this.matTransformStack.pop();\r\n        this.matTransformStack.push(matrixArrow);\r\n        this.drawModel(this.modelArrow, this.material, color);\r\n        this.matTransformStack.pop();\r\n        if (!hadCache) {\r\n            const newCache = {\r\n                x1: pos1.x, y1: pos1.y, z1: pos1.z,\r\n                x2: pos2.x, y2: pos2.y, z2: pos2.z,\r\n                scale,\r\n                matrixLine, matrixArrow,\r\n            };\r\n            this.saveCache(newCache);\r\n        }\r\n    }\r\n    doStencilStampPass(fn) {\r\n        this.gl.enable(this.gl.STENCIL_TEST);\r\n        this.gl.stencilFunc(this.gl.ALWAYS, 0, 0xff);\r\n        this.gl.stencilMask(0xff);\r\n        this.gl.clearStencil(0);\r\n        this.gl.clear(this.gl.STENCIL_BUFFER_BIT);\r\n        this.gl.colorMask(false, false, false, false);\r\n        this.gl.depthMask(false);\r\n        this.gl.cullFace(this.gl.FRONT);\r\n        this.gl.stencilOp(this.gl.KEEP, this.gl.INCR, this.gl.KEEP);\r\n        fn();\r\n        this.gl.cullFace(this.gl.BACK);\r\n        this.gl.stencilOp(this.gl.KEEP, this.gl.DECR, this.gl.KEEP);\r\n        fn();\r\n        this.gl.cullFace(this.gl.BACK);\r\n        this.gl.colorMask(true, true, true, true);\r\n        this.gl.stencilMask(0x00);\r\n        this.gl.stencilFunc(this.gl.NOTEQUAL, 0, 0xff);\r\n        fn();\r\n        this.gl.depthMask(true);\r\n        this.gl.disable(this.gl.STENCIL_TEST);\r\n    }\r\n}\r\nconst vertexSrc = `\r\n\tprecision highp float;\r\n\t\r\n\tattribute vec4 aPosition;\r\n\tattribute vec4 aNormal;\r\n\r\n\tuniform mat4 uMatModel;\r\n\tuniform mat4 uMatView;\r\n\tuniform mat4 uMatProj;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\r\n\t\tvScreenNormal = uMatView * uMatModel * vec4(aNormal.xyz, 0);\r\n\t\t\r\n\t\tgl_Position = uMatProj * uMatView * uMatModel * aPosition;\r\n\t}`;\r\nconst fragmentSrc = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\tuniform vec4 uAmbientColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\r\n\t\t\r\n\t\tvec4 ambientColor = uAmbientColor;\r\n\t\tvec4 diffuseColor = uDiffuseColor;\r\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\r\n\t\t\r\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\r\n\t\t\r\n\t\tgl_FragColor = diffuseColor * mix(ambientColor, lightColor, lightIncidence);\r\n\t}`;\r\nconst vertexSrcColor = `\r\n\tprecision highp float;\r\n\t\r\n\tattribute vec4 aPosition;\r\n\tattribute vec4 aNormal;\r\n\tattribute vec4 aColor;\r\n\r\n\tuniform mat4 uMatModel;\r\n\tuniform mat4 uMatView;\r\n\tuniform mat4 uMatProj;\r\n\t\r\n\tvarying float vDepth;\r\n\tvarying vec4 vWorldPos;\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\tvarying vec4 vColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvNormal = uMatModel * vec4(aNormal.xyz, 0);\r\n\t\tvScreenNormal = uMatModel * uMatView * vec4(aNormal.xyz, 0);\r\n\t\t\r\n\t\tvColor = aColor;\r\n\t\t\r\n\t\tvWorldPos = uMatModel * aPosition;\r\n\t\tvec4 position = uMatProj * uMatView * vWorldPos;\r\n\t\tgl_Position = position;\r\n\t\tvDepth = position.z / position.w;\r\n\t}`;\r\nconst fragmentSrcColor = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying float vDepth;\r\n\tvarying vec4 vWorldPos;\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\tvarying vec4 vColor;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\tuniform vec4 uAmbientColor;\r\n\tuniform float uFogDensity;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tvec4 lightDir = vec4(0, 0, -1, 0);\r\n\t\t\r\n\t\tvec4 ambientColor = uAmbientColor;\r\n\t\tvec4 diffuseColor = uDiffuseColor * vColor;\r\n\t\tvec4 lightColor = vec4(1, 1, 1, 1);\r\n\t\t\r\n\t\tfloat lightIncidence = max(0.0, dot(normalize(lightDir), normalize(vScreenNormal)));\r\n\t\t\r\n\t\tfloat patternFactor =\r\n\t\t\tmod(vWorldPos.x, 1.0) > 0.9 ||\r\n\t\t\tmod(vWorldPos.y, 1.0) > 0.9 ||\r\n\t\t\tmod(vWorldPos.z, 1.0) > 0.9 ? 0.0 : 1.0;\r\n\r\n\t\tgl_FragColor =\r\n\t\t\tmix(diffuseColor * vec4(0.85, 0.85, 0.85, 1), diffuseColor, patternFactor) *\r\n\t\t\tmix(ambientColor, lightColor, lightIncidence);\r\n\t}`;\r\nconst fragmentSrcUnshaded = `\r\n\tprecision highp float;\r\n\t\r\n\tvarying vec4 vNormal;\r\n\tvarying vec4 vScreenNormal;\r\n\t\r\n\tuniform vec4 uDiffuseColor;\r\n\r\n\tvoid main()\r\n\t{\r\n\t\tgl_FragColor = uDiffuseColor;\r\n\t}`;\r\n\n\n//# sourceURL=webpack://platformer/./src/gl/scene.ts?");

/***/ }),

/***/ "./src/gl/shader.ts":
/*!**************************!*\
  !*** ./src/gl/shader.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLShader\": () => (/* binding */ GLShader),\n/* harmony export */   \"GLProgram\": () => (/* binding */ GLProgram)\n/* harmony export */ });\nclass GLShader {\r\n    constructor(id) {\r\n        this.id = id;\r\n    }\r\n    static makeVertex(gl, src) {\r\n        return GLShader.make(gl, src, gl.VERTEX_SHADER);\r\n    }\r\n    static makeFragment(gl, src) {\r\n        return GLShader.make(gl, src, gl.FRAGMENT_SHADER);\r\n    }\r\n    static make(gl, src, kind) {\r\n        let shader = gl.createShader(kind);\r\n        gl.shaderSource(shader, src);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            console.error(\"Error compiling shader: \\n\\n\" + gl.getShaderInfoLog(shader));\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return new GLShader(shader);\r\n    }\r\n}\r\nclass GLProgram {\r\n    constructor(id) {\r\n        this.id = id;\r\n        this.attributes = {};\r\n        this.uniforms = {};\r\n        this.hasColor = false;\r\n    }\r\n    static makeFromSrc(gl, vertexSrc, fragmentSrc) {\r\n        let vertexShader = GLShader.makeVertex(gl, vertexSrc);\r\n        if (vertexShader == null)\r\n            throw \"vertexShader null\";\r\n        let fragmentShader = GLShader.makeFragment(gl, fragmentSrc);\r\n        if (fragmentShader == null)\r\n            throw \"fragmentShader null\";\r\n        return GLProgram.make(gl, vertexShader, fragmentShader);\r\n    }\r\n    static make(gl, vertexShader, fragmentShader) {\r\n        let program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader.id);\r\n        gl.attachShader(program, fragmentShader.id);\r\n        gl.linkProgram(program);\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n            console.error(\"Error creating program: \\n\\n\" + gl.getProgramInfoLog(program));\r\n            gl.deleteProgram(program);\r\n            throw \"GLProgram.make error\";\r\n        }\r\n        return new GLProgram(program);\r\n    }\r\n    registerLocations(gl, attrbs, unifs) {\r\n        for (let attrb of attrbs)\r\n            this.attributes[attrb] = gl.getAttribLocation(this.id, attrb);\r\n        for (let unif of unifs)\r\n            this.uniforms[unif] = gl.getUniformLocation(this.id, unif);\r\n        this.hasColor = (attrbs.find(a => a == \"aColor\") != null);\r\n        return this;\r\n    }\r\n    use(gl) {\r\n        gl.useProgram(this.id);\r\n        return this;\r\n    }\r\n    bindPosition(gl, attrb, buffer) {\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\r\n        gl.vertexAttribPointer(this.attributes[attrb], 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(this.attributes[attrb]);\r\n        return this;\r\n    }\r\n    bindNormals(gl, attrb, buffer) {\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\r\n        gl.vertexAttribPointer(this.attributes[attrb], 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(this.attributes[attrb]);\r\n        return this;\r\n    }\r\n    bindColors(gl, attrb, buffer) {\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);\r\n        gl.vertexAttribPointer(this.attributes[attrb], 4, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(this.attributes[attrb]);\r\n        return this;\r\n    }\r\n    setFloat(gl, unif, x) {\r\n        gl.uniform1f(this.uniforms[unif], x);\r\n        return this;\r\n    }\r\n    setMat4(gl, unif, matrix) {\r\n        gl.uniformMatrix4fv(this.uniforms[unif], false, matrix.asFloat32Array());\r\n        return this;\r\n    }\r\n    setVec4(gl, unif, vec) {\r\n        gl.uniform4fv(this.uniforms[unif], new Float32Array(vec));\r\n        return this;\r\n    }\r\n    drawTriangles(gl, count, offset = 0) {\r\n        gl.drawArrays(gl.TRIANGLES, offset, count);\r\n        return this;\r\n    }\r\n    drawTriangleStrip(gl, count, offset = 0) {\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, offset, count);\r\n        return this;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/gl/shader.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _director__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./director */ \"./src/director.ts\");\n\r\nmain();\r\nfunction main() {\r\n    const director = new _director__WEBPACK_IMPORTED_MODULE_0__.Director();\r\n    const render = () => {\r\n        director.process();\r\n        director.render();\r\n    };\r\n    window.addEventListener(\"keydown\", (ev) => {\r\n        director.keysHeld.add(ev.key.toLowerCase());\r\n    });\r\n    window.addEventListener(\"keyup\", (ev) => {\r\n        director.keysHeld.delete(ev.key.toLowerCase());\r\n    });\r\n    renderLoop(render);\r\n}\r\nfunction renderLoop(fn) {\r\n    fn();\r\n    //setTimeout(() => renderLoop(fn), 500)\r\n    window.requestAnimationFrame(() => renderLoop(fn));\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/main.ts?");

/***/ }),

/***/ "./src/math/geometry.ts":
/*!******************************!*\
  !*** ./src/math/geometry.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sweepSphereToPlane\": () => (/* binding */ sweepSphereToPlane),\n/* harmony export */   \"sweepSphereToSegment\": () => (/* binding */ sweepSphereToSegment),\n/* harmony export */   \"sweepSphereToLine\": () => (/* binding */ sweepSphereToLine),\n/* harmony export */   \"sweepSphereToPoint\": () => (/* binding */ sweepSphereToPoint)\n/* harmony export */ });\nfunction sweepSphereToPlane(spherePos, sphereSpeed, sphereRadius, pointOnPlane, planeNormal) {\r\n    // from WolframAlpha\r\n    // solve for t: {n, m, o} . ({x, y, z} + {u, v, w} * t) + d = r\r\n    const x = spherePos.x;\r\n    const y = spherePos.y;\r\n    const z = spherePos.z;\r\n    const u = sphereSpeed.x;\r\n    const v = sphereSpeed.y;\r\n    const w = sphereSpeed.z;\r\n    const r = sphereRadius;\r\n    const n = planeNormal.x;\r\n    const m = planeNormal.y;\r\n    const o = planeNormal.z;\r\n    const d = -pointOnPlane.dot(planeNormal);\r\n    const div = (m * v + n * u + o * w);\r\n    if (div == 0)\r\n        return Infinity;\r\n    const t = -(d + m * y + n * x + o * z - r) / div;\r\n    //if (t < 0 || t > 1)\r\n    //\treturn Infinity\r\n    return t;\r\n}\r\nfunction sweepSphereToSegment(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector) {\r\n    const t = sweepSphereToLine(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector.normalized());\r\n    if (!isFinite(t))\r\n        return Infinity;\r\n    const newPos = spherePos.add(sphereSpeed.scale(t));\r\n    const contact = newPos.add(newPos.directionToLine(lineVector, pointInLine));\r\n    const lineT = contact.sub(pointInLine).projectT(lineVector);\r\n    if (lineT < 0 || lineT > 1)\r\n        return Infinity;\r\n    return t;\r\n}\r\nfunction sweepSphereToLine(spherePos, sphereSpeed, sphereRadius, pointInLine, lineVector) {\r\n    // from WolframAlpha\r\n    // solve for t: ||{x + u * t, y + v * t, z + w * t} cross {n, m, o}|| = r\r\n    const x = spherePos.x - pointInLine.x;\r\n    const y = spherePos.y - pointInLine.y;\r\n    const z = spherePos.z - pointInLine.z;\r\n    const u = sphereSpeed.x;\r\n    const v = sphereSpeed.y;\r\n    const w = sphereSpeed.z;\r\n    const n = lineVector.x;\r\n    const m = lineVector.y;\r\n    const o = lineVector.z;\r\n    const r = sphereRadius;\r\n    const root1 = 2 * m * m * u * x +\r\n        2 * m * m * w * z -\r\n        2 * m * n * u * y -\r\n        2 * m * n * v * x -\r\n        2 * m * o * v * z -\r\n        2 * m * o * w * y +\r\n        2 * n * n * v * y +\r\n        2 * n * n * w * z -\r\n        2 * n * o * u * z -\r\n        2 * n * o * w * x +\r\n        2 * o * o * u * x +\r\n        2 * o * o * v * y;\r\n    const root2 = m * m * u * u +\r\n        m * m * w * w -\r\n        2 * m * n * u * v -\r\n        2 * m * o * v * w +\r\n        n * n * v * v +\r\n        n * n * w * w -\r\n        2 * n * o * u * w +\r\n        o * o * u * u +\r\n        o * o * v * v;\r\n    const root3 = m * m * x * x +\r\n        m * m * z * z -\r\n        2 * m * n * x * y -\r\n        2 * m * o * y * z +\r\n        n * n * y * y +\r\n        n * n * z * z -\r\n        2 * n * o * x * z +\r\n        o * o * x * x +\r\n        o * o * y * y -\r\n        r * r;\r\n    const rootInner = root1 * root1 - 4 * root2 * root3;\r\n    if (rootInner < 0)\r\n        return Infinity;\r\n    const root = Math.sqrt(rootInner);\r\n    const div = (2 * root2);\r\n    if (div == 0)\r\n        return Infinity;\r\n    const t1 = (-root - root1) / div;\r\n    const t2 = (root - root1) / div;\r\n    const t = Math.min(t1, t2);\r\n    //if (t < 0 || t > 1)\r\n    //\treturn Infinity\r\n    return t;\r\n}\r\nfunction sweepSphereToPoint(spherePos, sphereSpeed, sphereRadius, point) {\r\n    // from WolframAlpha\r\n    // solve for t: ||{x, y, z} + {u, v, w} * t|| = r\r\n    const x = spherePos.x - point.x;\r\n    const y = spherePos.y - point.y;\r\n    const z = spherePos.z - point.z;\r\n    const u = sphereSpeed.x;\r\n    const v = sphereSpeed.y;\r\n    const w = sphereSpeed.z;\r\n    const r = sphereRadius;\r\n    const div = 2 * (u * u + v * v + w * w);\r\n    if (div == 0)\r\n        return Infinity;\r\n    const root = Math.pow(2 * u * x + 2 * v * y + 2 * w * z, 2) -\r\n        4 * (u * u + v * v + w * w) *\r\n            (-(r * r) + x * x + y * y + z * z);\r\n    if (root < 0)\r\n        return Infinity;\r\n    const t1 = 1 / div * (-Math.sqrt(root) - 2 * u * x - 2 * v * y - 2 * w * z);\r\n    const t2 = 1 / div * (Math.sqrt(root) - 2 * u * x - 2 * v * y - 2 * w * z);\r\n    const t = Math.min(t1, t2);\r\n    //if (t < 0 || t > 1)\r\n    //\treturn Infinity\r\n    return t;\r\n}\r\n/*export function linePointMinimumVec(origin, direction, point)\r\n{\r\n    let pointFromOrigin = point.sub(origin)\r\n    let pointOverDirection = pointFromOrigin.project(direction)\r\n    \r\n    return pointFromOrigin.sub(pointOverDirection)\r\n}\r\n\r\n\r\nexport function linePointDistance(origin, direction, point)\r\n{\r\n    return Geometry.linePointMinimumVec(origin, direction, point).magn()\r\n}\r\n\r\n\r\nexport function lineLineDistance(origin1, direction1, origin2, direction2)\r\n{\r\n    let cross = direction1.cross(direction2)\r\n    let crossMagn = cross.magn()\r\n    \r\n    if (crossMagn < 0.001)\r\n        return Infinity // wrong but works\r\n    \r\n    return Math.abs(cross.scale(1 / crossMagn).dot(origin2.sub(origin1)))\r\n}\r\n\r\n\r\nexport function lineZPlaneIntersection(origin, direction, planeZ)\r\n{\r\n    return origin.add(direction.scale((planeZ - origin.z) / direction.z))\r\n}*/ \r\n\n\n//# sourceURL=webpack://platformer/./src/math/geometry.ts?");

/***/ }),

/***/ "./src/math/mat4.ts":
/*!**************************!*\
  !*** ./src/math/mat4.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mat4)\n/* harmony export */ });\n/* harmony import */ var _vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vec3 */ \"./src/math/vec3.ts\");\n\r\nclass Mat4 {\r\n    constructor(cells) {\r\n        this.m = new Float32Array(cells);\r\n    }\r\n    static identity() {\r\n        return identity;\r\n    }\r\n    static translation(x, y, z) {\r\n        return new Mat4([\r\n            1, 0, 0, 0,\r\n            0, 1, 0, 0,\r\n            0, 0, 1, 0,\r\n            x, y, z, 1\r\n        ]);\r\n    }\r\n    static scale(x, y, z) {\r\n        return new Mat4([\r\n            x, 0, 0, 0,\r\n            0, y, 0, 0,\r\n            0, 0, z, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n    }\r\n    static rotation(vec, radians) {\r\n        const x = vec.x;\r\n        const y = vec.y;\r\n        const z = vec.z;\r\n        const c = Math.cos(radians);\r\n        const s = Math.sin(radians);\r\n        const t = 1 - c;\r\n        return new Mat4([\r\n            t * x * x + c, t * x * y - z * s, t * x * z + y * s, 0,\r\n            t * x * y + z * s, t * y * y + c, t * y * z - x * s, 0,\r\n            t * x * z - y * s, t * y * z + x * s, t * z * z + c, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n    }\r\n    static rotationFromTo(fromVec, toVec) {\r\n        const axis = fromVec.cross(toVec).normalized();\r\n        const angle = Math.acos(fromVec.dot(toVec));\r\n        return Mat4.rotation(axis, -angle);\r\n    }\r\n    static basisRotation(i1, j1, k1, i2, j2, k2) {\r\n        const basis1 = new Mat4([\r\n            i1.x, j1.x, k1.x, 0,\r\n            i1.y, j1.y, k1.y, 0,\r\n            i1.z, j1.z, k1.z, 0,\r\n            0, 0, 0, 1,\r\n        ]);\r\n        const basis2 = new Mat4([\r\n            i2.x, j2.x, k2.x, 0,\r\n            i2.y, j2.y, k2.y, 0,\r\n            i2.z, j2.z, k2.z, 0,\r\n            0, 0, 0, 1,\r\n        ]);\r\n        return basis1.mul(basis2.transpose());\r\n    }\r\n    static ortho(left, right, top, bottom, near, far) {\r\n        return new Mat4([\r\n            2 / (right - left), 0, 0, 0,\r\n            0, 2 / (top - bottom), 0, 0,\r\n            0, 0, -2 / (far - near), 0,\r\n            -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1\r\n        ]);\r\n    }\r\n    static frustum(left, right, top, bottom, near, far) {\r\n        return new Mat4([\r\n            2 * near / (right - left), 0, 0, 0,\r\n            0, 2 * near / (top - bottom), 0, 0,\r\n            (right + left) / (right - left), (top + bottom) / (top - bottom), -(far + near) / (far - near), -1,\r\n            0, 0, -(2 * far * near) / (far - near), 0\r\n        ]);\r\n    }\r\n    static perspective(fovyRadians, aspectWidthByHeight, near, far) {\r\n        const h = Math.tan(fovyRadians) * near;\r\n        const w = h * aspectWidthByHeight;\r\n        return Mat4.frustum(-w, w, -h, h, near, far);\r\n    }\r\n    static lookat(eye, target, up) {\r\n        const zaxis = eye.sub(target).normalized();\r\n        const xaxis = zaxis.cross(up).normalized();\r\n        const yaxis = zaxis.cross(xaxis);\r\n        return new Mat4([\r\n            xaxis.x, yaxis.x, zaxis.x, 0,\r\n            xaxis.y, yaxis.y, zaxis.y, 0,\r\n            xaxis.z, yaxis.z, zaxis.z, 0,\r\n            -xaxis.dot(eye), -yaxis.dot(eye), -zaxis.dot(eye), 1\r\n        ]);\r\n    }\r\n    transpose() {\r\n        return new Mat4([\r\n            this.m[0 * 4 + 0], this.m[1 * 4 + 0], this.m[2 * 4 + 0], this.m[3 * 4 + 0],\r\n            this.m[0 * 4 + 1], this.m[1 * 4 + 1], this.m[2 * 4 + 1], this.m[3 * 4 + 1],\r\n            this.m[0 * 4 + 2], this.m[1 * 4 + 2], this.m[2 * 4 + 2], this.m[3 * 4 + 2],\r\n            this.m[0 * 4 + 3], this.m[1 * 4 + 3], this.m[2 * 4 + 3], this.m[3 * 4 + 3]\r\n        ]);\r\n    }\r\n    mul(other) {\r\n        if (this === identity)\r\n            return other;\r\n        if (other === identity)\r\n            return this;\r\n        const a00 = +this.m[0 * 4 + 0];\r\n        const a01 = +this.m[0 * 4 + 1];\r\n        const a02 = +this.m[0 * 4 + 2];\r\n        const a03 = +this.m[0 * 4 + 3];\r\n        const a10 = +this.m[1 * 4 + 0];\r\n        const a11 = +this.m[1 * 4 + 1];\r\n        const a12 = +this.m[1 * 4 + 2];\r\n        const a13 = +this.m[1 * 4 + 3];\r\n        const a20 = +this.m[2 * 4 + 0];\r\n        const a21 = +this.m[2 * 4 + 1];\r\n        const a22 = +this.m[2 * 4 + 2];\r\n        const a23 = +this.m[2 * 4 + 3];\r\n        const a30 = +this.m[3 * 4 + 0];\r\n        const a31 = +this.m[3 * 4 + 1];\r\n        const a32 = +this.m[3 * 4 + 2];\r\n        const a33 = +this.m[3 * 4 + 3];\r\n        const b00 = +other.m[0 * 4 + 0];\r\n        const b01 = +other.m[0 * 4 + 1];\r\n        const b02 = +other.m[0 * 4 + 2];\r\n        const b03 = +other.m[0 * 4 + 3];\r\n        const b10 = +other.m[1 * 4 + 0];\r\n        const b11 = +other.m[1 * 4 + 1];\r\n        const b12 = +other.m[1 * 4 + 2];\r\n        const b13 = +other.m[1 * 4 + 3];\r\n        const b20 = +other.m[2 * 4 + 0];\r\n        const b21 = +other.m[2 * 4 + 1];\r\n        const b22 = +other.m[2 * 4 + 2];\r\n        const b23 = +other.m[2 * 4 + 3];\r\n        const b30 = +other.m[3 * 4 + 0];\r\n        const b31 = +other.m[3 * 4 + 1];\r\n        const b32 = +other.m[3 * 4 + 2];\r\n        const b33 = +other.m[3 * 4 + 3];\r\n        const m00 = (a00 * b00) + (a01 * b10) + (a02 * b20) + (a03 * b30);\r\n        const m01 = (a00 * b01) + (a01 * b11) + (a02 * b21) + (a03 * b31);\r\n        const m02 = (a00 * b02) + (a01 * b12) + (a02 * b22) + (a03 * b32);\r\n        const m03 = (a00 * b03) + (a01 * b13) + (a02 * b23) + (a03 * b33);\r\n        const m10 = (a10 * b00) + (a11 * b10) + (a12 * b20) + (a13 * b30);\r\n        const m11 = (a10 * b01) + (a11 * b11) + (a12 * b21) + (a13 * b31);\r\n        const m12 = (a10 * b02) + (a11 * b12) + (a12 * b22) + (a13 * b32);\r\n        const m13 = (a10 * b03) + (a11 * b13) + (a12 * b23) + (a13 * b33);\r\n        const m20 = (a20 * b00) + (a21 * b10) + (a22 * b20) + (a23 * b30);\r\n        const m21 = (a20 * b01) + (a21 * b11) + (a22 * b21) + (a23 * b31);\r\n        const m22 = (a20 * b02) + (a21 * b12) + (a22 * b22) + (a23 * b32);\r\n        const m23 = (a20 * b03) + (a21 * b13) + (a22 * b23) + (a23 * b33);\r\n        const m30 = (a30 * b00) + (a31 * b10) + (a32 * b20) + (a33 * b30);\r\n        const m31 = (a30 * b01) + (a31 * b11) + (a32 * b21) + (a33 * b31);\r\n        const m32 = (a30 * b02) + (a31 * b12) + (a32 * b22) + (a33 * b32);\r\n        const m33 = (a30 * b03) + (a31 * b13) + (a32 * b23) + (a33 * b33);\r\n        return new Mat4([\r\n            m00, m01, m02, m03,\r\n            m10, m11, m12, m13,\r\n            m20, m21, m22, m23,\r\n            m30, m31, m32, m33\r\n        ]);\r\n        /*let result =\r\n        [\r\n            [0, 0, 0, 0],\r\n            [0, 0, 0, 0],\r\n            [0, 0, 0, 0],\r\n            [0, 0, 0, 0]\r\n        ]\r\n\r\n        for (let j = 0; j < 4; j++)\r\n        {\r\n            for (let i = 0; i < 4; i++)\r\n            {\r\n                let acc = 0\r\n                for (let k = 0; k < 4; k++)\r\n                    acc += this.m[j * 4 + k] * other.m[k * 4 + i]\r\n                \r\n                result[j][i] = acc\r\n            }\r\n        }\r\n        \r\n        return new Mat4(result)*/\r\n    }\r\n    mulVec4(v) {\r\n        let result = [0, 0, 0, 0];\r\n        for (let i = 0; i < 4; i++) {\r\n            let acc = 0;\r\n            for (let k = 0; k < 4; k++)\r\n                acc += this.m[i * 4 + k] * v[k];\r\n            result[i] = acc;\r\n        }\r\n        return result;\r\n    }\r\n    mulPoint(vec) {\r\n        const v = [vec.x, vec.y, vec.z, 1];\r\n        let result = [0, 0, 0, 0];\r\n        for (let i = 0; i < 4; i++) {\r\n            let acc = 0;\r\n            for (let k = 0; k < 4; k++)\r\n                acc += this.m[i * 4 + k] * v[k];\r\n            result[i] = acc;\r\n        }\r\n        return new _vec3__WEBPACK_IMPORTED_MODULE_0__.default(result[0], result[1], result[2]);\r\n    }\r\n    mulDirection(vec) {\r\n        const v = [vec.x, vec.y, vec.z, 0];\r\n        let result = [0, 0, 0, 0];\r\n        for (let i = 0; i < 4; i++) {\r\n            let acc = 0;\r\n            for (let k = 0; k < 4; k++)\r\n                acc += this.m[i * 4 + k] * v[k];\r\n            result[i] = acc;\r\n        }\r\n        return new _vec3__WEBPACK_IMPORTED_MODULE_0__.default(result[0], result[1], result[2]);\r\n    }\r\n    asFloat32Array() {\r\n        return this.m; /*new Float32Array([\r\n            this.m[0 * 4 + 0], this.m[0 * 4 + 1], this.m[0 * 4 + 2], this.m[0 * 4 + 3],\r\n            this.m[1 * 4 + 0], this.m[1 * 4 + 1], this.m[1 * 4 + 2], this.m[1 * 4 + 3],\r\n            this.m[2 * 4 + 0], this.m[2 * 4 + 1], this.m[2 * 4 + 2], this.m[2 * 4 + 3],\r\n            this.m[3 * 4 + 0], this.m[3 * 4 + 1], this.m[3 * 4 + 2], this.m[3 * 4 + 3]])*/\r\n    }\r\n    invert() {\r\n        // From https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix\r\n        const a2323 = this.m[2 * 4 + 2] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 2];\r\n        const a1323 = this.m[2 * 4 + 1] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 1];\r\n        const a1223 = this.m[2 * 4 + 1] * this.m[3 * 4 + 2] - this.m[2 * 4 + 2] * this.m[3 * 4 + 1];\r\n        const a0323 = this.m[2 * 4 + 0] * this.m[3 * 4 + 3] - this.m[2 * 4 + 3] * this.m[3 * 4 + 0];\r\n        const a0223 = this.m[2 * 4 + 0] * this.m[3 * 4 + 2] - this.m[2 * 4 + 2] * this.m[3 * 4 + 0];\r\n        const a0123 = this.m[2 * 4 + 0] * this.m[3 * 4 + 1] - this.m[2 * 4 + 1] * this.m[3 * 4 + 0];\r\n        const a2313 = this.m[1 * 4 + 2] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 2];\r\n        const a1313 = this.m[1 * 4 + 1] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 1];\r\n        const a1213 = this.m[1 * 4 + 1] * this.m[3 * 4 + 2] - this.m[1 * 4 + 2] * this.m[3 * 4 + 1];\r\n        const a2312 = this.m[1 * 4 + 2] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 2];\r\n        const a1312 = this.m[1 * 4 + 1] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 1];\r\n        const a1212 = this.m[1 * 4 + 1] * this.m[2 * 4 + 2] - this.m[1 * 4 + 2] * this.m[2 * 4 + 1];\r\n        const a0313 = this.m[1 * 4 + 0] * this.m[3 * 4 + 3] - this.m[1 * 4 + 3] * this.m[3 * 4 + 0];\r\n        const a0213 = this.m[1 * 4 + 0] * this.m[3 * 4 + 2] - this.m[1 * 4 + 2] * this.m[3 * 4 + 0];\r\n        const a0312 = this.m[1 * 4 + 0] * this.m[2 * 4 + 3] - this.m[1 * 4 + 3] * this.m[2 * 4 + 0];\r\n        const a0212 = this.m[1 * 4 + 0] * this.m[2 * 4 + 2] - this.m[1 * 4 + 2] * this.m[2 * 4 + 0];\r\n        const a0113 = this.m[1 * 4 + 0] * this.m[3 * 4 + 1] - this.m[1 * 4 + 1] * this.m[3 * 4 + 0];\r\n        const a0112 = this.m[1 * 4 + 0] * this.m[2 * 4 + 1] - this.m[1 * 4 + 1] * this.m[2 * 4 + 0];\r\n        const det = 1 / (this.m[0 * 4 + 0] * (this.m[1 * 4 + 1] * a2323 - this.m[1 * 4 + 2] * a1323 + this.m[1 * 4 + 3] * a1223) -\r\n            this.m[0 * 4 + 1] * (this.m[1 * 4 + 0] * a2323 - this.m[1 * 4 + 2] * a0323 + this.m[1 * 4 + 3] * a0223) +\r\n            this.m[0 * 4 + 2] * (this.m[1 * 4 + 0] * a1323 - this.m[1 * 4 + 1] * a0323 + this.m[1 * 4 + 3] * a0123) -\r\n            this.m[0 * 4 + 3] * (this.m[1 * 4 + 0] * a1223 - this.m[1 * 4 + 1] * a0223 + this.m[1 * 4 + 2] * a0123));\r\n        return new Mat4([\r\n            det * (this.m[1 * 4 + 1] * a2323 - this.m[1 * 4 + 2] * a1323 + this.m[1 * 4 + 3] * a1223),\r\n            det * -(this.m[0 * 4 + 1] * a2323 - this.m[0 * 4 + 2] * a1323 + this.m[0 * 4 + 3] * a1223),\r\n            det * (this.m[0 * 4 + 1] * a2313 - this.m[0 * 4 + 2] * a1313 + this.m[0 * 4 + 3] * a1213),\r\n            det * -(this.m[0 * 4 + 1] * a2312 - this.m[0 * 4 + 2] * a1312 + this.m[0 * 4 + 3] * a1212),\r\n            det * -(this.m[1 * 4 + 0] * a2323 - this.m[1 * 4 + 2] * a0323 + this.m[1 * 4 + 3] * a0223),\r\n            det * (this.m[0 * 4 + 0] * a2323 - this.m[0 * 4 + 2] * a0323 + this.m[0 * 4 + 3] * a0223),\r\n            det * -(this.m[0 * 4 + 0] * a2313 - this.m[0 * 4 + 2] * a0313 + this.m[0 * 4 + 3] * a0213),\r\n            det * (this.m[0 * 4 + 0] * a2312 - this.m[0 * 4 + 2] * a0312 + this.m[0 * 4 + 3] * a0212),\r\n            det * (this.m[1 * 4 + 0] * a1323 - this.m[1 * 4 + 1] * a0323 + this.m[1 * 4 + 3] * a0123),\r\n            det * -(this.m[0 * 4 + 0] * a1323 - this.m[0 * 4 + 1] * a0323 + this.m[0 * 4 + 3] * a0123),\r\n            det * (this.m[0 * 4 + 0] * a1313 - this.m[0 * 4 + 1] * a0313 + this.m[0 * 4 + 3] * a0113),\r\n            det * -(this.m[0 * 4 + 0] * a1312 - this.m[0 * 4 + 1] * a0312 + this.m[0 * 4 + 3] * a0112),\r\n            det * -(this.m[1 * 4 + 0] * a1223 - this.m[1 * 4 + 1] * a0223 + this.m[1 * 4 + 2] * a0123),\r\n            det * (this.m[0 * 4 + 0] * a1223 - this.m[0 * 4 + 1] * a0223 + this.m[0 * 4 + 2] * a0123),\r\n            det * -(this.m[0 * 4 + 0] * a1213 - this.m[0 * 4 + 1] * a0213 + this.m[0 * 4 + 2] * a0113),\r\n            det * (this.m[0 * 4 + 0] * a1212 - this.m[0 * 4 + 1] * a0212 + this.m[0 * 4 + 2] * a0112),\r\n        ]).transpose();\r\n    }\r\n}\r\nconst identity = new Mat4([\r\n    1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1\r\n]);\r\n\n\n//# sourceURL=webpack://platformer/./src/math/mat4.ts?");

/***/ }),

/***/ "./src/math/vec3.ts":
/*!**************************!*\
  !*** ./src/math/vec3.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vec3)\n/* harmony export */ });\nclass Vec3 {\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    clone() {\r\n        return new Vec3(this.x, this.y, this.z);\r\n    }\r\n    magn() {\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n    magnSqr() {\r\n        return this.dot(this);\r\n    }\r\n    withZ(z) {\r\n        return new Vec3(this.x, this.y, z);\r\n    }\r\n    withMagn(magn) {\r\n        return this.normalized().scale(magn);\r\n    }\r\n    withAddedMagn(t) {\r\n        return this.normalized().scale(this.magn() + t);\r\n    }\r\n    normalized() {\r\n        const magn = this.magn();\r\n        if (magn == 0)\r\n            return this;\r\n        return new Vec3(this.x / magn, this.y / magn, this.z / magn);\r\n    }\r\n    add(other) {\r\n        return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);\r\n    }\r\n    sub(other) {\r\n        return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);\r\n    }\r\n    neg() {\r\n        return new Vec3(-this.x, -this.y, -this.z);\r\n    }\r\n    scale(f) {\r\n        return new Vec3(this.x * f, this.y * f, this.z * f);\r\n    }\r\n    mul(other) {\r\n        return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);\r\n    }\r\n    dot(other) {\r\n        return (this.x * other.x + this.y * other.y + this.z * other.z);\r\n    }\r\n    cross(other) {\r\n        return new Vec3(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);\r\n    }\r\n    lerp(other, amount) {\r\n        return new Vec3(this.x + (other.x - this.x) * amount, this.y + (other.y - this.y) * amount, this.z + (other.z - this.z) * amount);\r\n    }\r\n    min(other) {\r\n        if (other == null)\r\n            return this;\r\n        return new Vec3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));\r\n    }\r\n    max(other) {\r\n        if (other == null)\r\n            return this;\r\n        return new Vec3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));\r\n    }\r\n    projectT(other) {\r\n        return this.dot(other) / other.dot(other);\r\n    }\r\n    project(other) {\r\n        return other.scale(this.dot(other) / other.dot(other));\r\n    }\r\n    projectOnPlane(planeNormal) {\r\n        return this.sub(this.project(planeNormal));\r\n    }\r\n    directionToLine(lineVector, pointOnLine) {\r\n        const vec = this.sub(pointOnLine);\r\n        const proj = vec.sub(vec.project(lineVector));\r\n        return proj;\r\n    }\r\n    directionToPlane(planeNormal, pointOnPlane) {\r\n        const p = this.sub(pointOnPlane);\r\n        return p.sub(p.project(planeNormal)).add(pointOnPlane).sub(this);\r\n    }\r\n    signedSqrDistanceToPlane(planeNormal, pointOnPlane) {\r\n        const distPlane = this.directionToPlane(planeNormal, pointOnPlane);\r\n        const dotPlane = this.sub(pointOnPlane).dot(planeNormal);\r\n        return distPlane.magnSqr() * Math.sign(dotPlane);\r\n    }\r\n    asArray() {\r\n        return [this.x, this.y, this.z];\r\n    }\r\n    isFinite() {\r\n        return isFinite(this.x) && isFinite(this.y) && isFinite(this.z);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/math/vec3.ts?");

/***/ }),

/***/ "./src/objects/_object.ts":
/*!********************************!*\
  !*** ./src/objects/_object.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Object\": () => (/* binding */ Object)\n/* harmony export */ });\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\r\nclass Object {\r\n    constructor() {\r\n        this.position = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__.default(0, 0, 0);\r\n        this.scale = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__.default(1, 1, 1);\r\n    }\r\n    init() {\r\n    }\r\n    process() {\r\n    }\r\n    render() {\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/_object.ts?");

/***/ }),

/***/ "./src/objects/camera.ts":
/*!*******************************!*\
  !*** ./src/objects/camera.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _kart__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./kart */ \"./src/objects/kart.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./player */ \"./src/objects/player.ts\");\n/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./test */ \"./src/objects/test.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Camera extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.lookAt = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.up = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, -1);\r\n    }\r\n    init() {\r\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.default();\r\n        builder.addCube(-1, -1, -1, 1, 1, 1);\r\n        builder.calculateNormals();\r\n        this.model = builder.makeModel(this.director.gl);\r\n    }\r\n    setMatrices() {\r\n        this.director.scene.setProjection(_math_mat4__WEBPACK_IMPORTED_MODULE_3__.default.perspective(60, this.director.canvasW / this.director.canvasH, 0.1, 10000));\r\n        this.director.scene.setView(_math_mat4__WEBPACK_IMPORTED_MODULE_3__.default.lookat(this.position, this.lookAt, this.up));\r\n    }\r\n    process() {\r\n        let target = this.director.objectFind(_kart__WEBPACK_IMPORTED_MODULE_4__.Kart);\r\n        if (!target)\r\n            target = this.director.objectFind(_player__WEBPACK_IMPORTED_MODULE_5__.Player);\r\n        if (!target)\r\n            target = this.director.objectFind(_test__WEBPACK_IMPORTED_MODULE_6__.Test);\r\n        if (!target)\r\n            return;\r\n        if (target instanceof _kart__WEBPACK_IMPORTED_MODULE_4__.Kart) {\r\n            this.lookAt = target.center.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, -0.5));\r\n            this.position = target.center\r\n                .sub(target.forward.withZ(0).normalized().scale(5))\r\n                .add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, -1.5));\r\n            /*this.position = target.center\r\n                .sub(target.forward.normalized().scale(5))\r\n                .add(target.up.normalized().scale(1.5))*/\r\n        }\r\n        else {\r\n            this.lookAt = target.position;\r\n            const speed = 0.5;\r\n            const goalDistance = 5;\r\n            const dirToLookat = this.lookAt.sub(this.position).normalized().withZ(0).scale(goalDistance);\r\n            const goalPos = this.lookAt.sub(dirToLookat).add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0.5 - goalDistance * 0.45));\r\n            this.position = goalPos;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/camera.ts?");

/***/ }),

/***/ "./src/objects/kart.ts":
/*!*****************************!*\
  !*** ./src/objects/kart.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kart\": () => (/* binding */ Kart)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _sphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere */ \"./src/objects/sphere.ts\");\n/* harmony import */ var _stage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stage */ \"./src/objects/stage.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction approach(from, to, step) {\r\n    if (from < to)\r\n        return Math.min(from + step, to);\r\n    else\r\n        return Math.max(from - step, to);\r\n}\r\nclass Kart extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.engineSpeed = 0;\r\n        this.steerSpeed = 0;\r\n    }\r\n    init() {\r\n        this.bodies =\r\n            [\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n                new _sphere__WEBPACK_IMPORTED_MODULE_4__.Sphere(),\r\n            ];\r\n        for (const body of this.bodies)\r\n            body.init(this.director);\r\n        this.joints = [];\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        const bodyForwardLen = 0.25;\r\n        const bodySideLen = 0.125;\r\n        const chassiHeight = -0.15;\r\n        const wheelRadius = 0.15;\r\n        const pos = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(50, 50, -15);\r\n        this.bodies[0].id = 0;\r\n        this.bodies[1].id = 1;\r\n        this.bodies[2].id = 2;\r\n        this.bodies[3].id = 3;\r\n        this.bodies[4].id = 4;\r\n        this.bodies[5].id = 5;\r\n        this.bodies[0].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-bodyForwardLen, -bodySideLen, 0));\r\n        this.bodies[1].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-bodyForwardLen, bodySideLen, 0));\r\n        this.bodies[2].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(bodyForwardLen, bodySideLen, 0));\r\n        this.bodies[3].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(bodyForwardLen, -bodySideLen, 0));\r\n        this.bodies[4].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0));\r\n        this.bodies[5].pos = pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, chassiHeight));\r\n        this.bodies[0].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[1].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[2].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[3].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[4].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[5].speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.bodies[0].radius = wheelRadius;\r\n        this.bodies[1].radius = wheelRadius;\r\n        this.bodies[2].radius = wheelRadius;\r\n        this.bodies[3].radius = wheelRadius;\r\n        this.bodies[4].radius = wheelRadius;\r\n        this.bodies[5].radius = wheelRadius;\r\n        const addJoint = (body1, body2, tensionK, frictionK) => {\r\n            this.joints.push({\r\n                body1,\r\n                body2,\r\n                length: body1.pos.sub(body2.pos).magn(),\r\n                tensionK,\r\n                frictionK,\r\n            });\r\n        };\r\n        this.joints = [];\r\n        const tensionK = 0.5;\r\n        const frictionK = 0.05;\r\n        // Outer Edges\r\n        addJoint(this.bodies[0], this.bodies[1], tensionK, frictionK);\r\n        addJoint(this.bodies[2], this.bodies[3], tensionK, frictionK);\r\n        addJoint(this.bodies[0], this.bodies[3], tensionK, frictionK);\r\n        addJoint(this.bodies[1], this.bodies[2], tensionK, frictionK);\r\n        // Chassi\r\n        addJoint(this.bodies[0], this.bodies[4], tensionK, frictionK);\r\n        addJoint(this.bodies[1], this.bodies[4], tensionK, frictionK);\r\n        addJoint(this.bodies[2], this.bodies[4], tensionK, frictionK);\r\n        addJoint(this.bodies[3], this.bodies[4], tensionK, frictionK);\r\n        addJoint(this.bodies[0], this.bodies[5], tensionK, frictionK);\r\n        addJoint(this.bodies[1], this.bodies[5], tensionK, frictionK);\r\n        addJoint(this.bodies[2], this.bodies[5], tensionK, frictionK);\r\n        addJoint(this.bodies[3], this.bodies[5], tensionK, frictionK);\r\n        addJoint(this.bodies[4], this.bodies[5], tensionK, frictionK);\r\n    }\r\n    process() {\r\n        this.handleVectors();\r\n        this.handleMovement();\r\n        this.handleJoints();\r\n        const stage = this.director.objectFind(_stage__WEBPACK_IMPORTED_MODULE_5__.Stage);\r\n        if (!stage)\r\n            return;\r\n        for (const body of this.bodies) {\r\n            body.processGravity();\r\n            body.processCollision(stage.collision);\r\n        }\r\n    }\r\n    handleVectors() {\r\n        this.centerPrev = this.center ?? new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        this.center = new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, 0, 0);\r\n        for (const body of this.bodies)\r\n            this.center = this.center.add(body.pos);\r\n        this.center = this.center.scale(1 / this.bodies.length);\r\n        this.position = this.center;\r\n        this.speed = this.center.sub(this.centerPrev);\r\n        this.nose = this.bodies[0].pos.add(this.bodies[1].pos).scale(1 / 2);\r\n        this.forward = this.nose.sub(this.center).normalized();\r\n        this.up = this.forward.cross(this.bodies[0].pos.sub(this.bodies[1].pos)).normalized();\r\n        if (this.up.z > 0)\r\n            this.up = this.up.neg();\r\n        this.right = this.up.cross(this.forward);\r\n    }\r\n    handleMovement() {\r\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\r\n        if (!camera)\r\n            return;\r\n        const accel = 0.015;\r\n        const maxSpeed = 0.22;\r\n        const steerAccel = 0.0025;\r\n        const steerDecel = 0.005;\r\n        const steerMaxSpeed = 0.02;\r\n        if (this.director.keysHeld.has(\"arrowup\") ||\r\n            this.director.keysHeld.has(\"w\") ||\r\n            this.director.keysHeld.has(\" \"))\r\n            this.engineSpeed = approach(this.engineSpeed, 1, 1);\r\n        else if (this.director.keysHeld.has(\"arrowdown\") ||\r\n            this.director.keysHeld.has(\"s\") ||\r\n            this.director.keysHeld.has(\"x\"))\r\n            this.engineSpeed = approach(this.engineSpeed, -1, 1);\r\n        else\r\n            this.engineSpeed = 0; //approach(this.engineSpeed, 0, decel)\r\n        if (this.director.keysHeld.has(\"arrowleft\") ||\r\n            this.director.keysHeld.has(\"a\"))\r\n            this.steerSpeed = approach(this.steerSpeed, -steerMaxSpeed, steerAccel);\r\n        else if (this.director.keysHeld.has(\"arrowright\") ||\r\n            this.director.keysHeld.has(\"d\"))\r\n            this.steerSpeed = approach(this.steerSpeed, steerMaxSpeed, steerAccel);\r\n        else\r\n            this.steerSpeed = approach(this.steerSpeed, 0, steerDecel);\r\n        for (const body of this.bodies) {\r\n            if (!body.touchingGround)\r\n                continue;\r\n            const targetForce = this.forward.scale(this.engineSpeed * maxSpeed);\r\n            const accelForce = targetForce.sub(body.speed).scale(accel);\r\n            body.speed = body.speed.add(accelForce);\r\n            const sideFriction = body.speed.project(this.right);\r\n            body.speed = body.speed.sub(sideFriction.scale(0.25));\r\n        }\r\n        const steerMatrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__.default.rotation(this.up, this.steerSpeed);\r\n        for (const body of this.bodies) {\r\n            const fromCenter = body.pos.sub(this.center);\r\n            const rotated = steerMatrix.mulPoint(fromCenter);\r\n            body.instantSpeed = body.instantSpeed.add(rotated.sub(fromCenter));\r\n        }\r\n    }\r\n    handleJoints() {\r\n        for (const joint of this.joints) {\r\n            const dir = joint.body1.pos.sub(joint.body2.pos);\r\n            const dirN = dir.normalized();\r\n            const dist = dir.magn();\r\n            const tensionForce = dirN.scale((dist - joint.length) * joint.tensionK);\r\n            joint.body1.speed = joint.body1.speed.sub(tensionForce);\r\n            joint.body2.speed = joint.body2.speed.add(tensionForce);\r\n            const frictionForce = joint.body1.speed.sub(joint.body2.speed).scale(joint.frictionK);\r\n            joint.body1.speed = joint.body1.speed.sub(frictionForce);\r\n            joint.body2.speed = joint.body2.speed.add(frictionForce);\r\n        }\r\n    }\r\n    render() {\r\n        for (const body of this.bodies)\r\n            body.render();\r\n        for (const joint of this.joints) {\r\n            this.director.scene.drawArrow(joint.body1.pos, joint.body2.pos, 0.025, [1, 1, 1, 1]);\r\n        }\r\n        /*this.director.scene.drawArrow(\r\n            this.center,\r\n            this.center.add(this.forward.withMagn(0.5)),\r\n            0.025,\r\n            [1, 0, 0, 1])\r\n            \r\n        this.director.scene.drawArrow(\r\n            this.center,\r\n            this.center.add(this.right.withMagn(0.5)),\r\n            0.025,\r\n            [0, 0, 1, 1])*/\r\n        this.director.scene.drawArrow(this.center, this.center.add(this.up.withMagn(100)), 0.025, [0, 1, 0, 1]);\r\n        this.director.scene.drawArrow(this.center, this.center.add(this.bodies[0].speed.scale(100)), 0.025, [1, 1, 0, 1]);\r\n        this.director.scene.drawArrow(this.center, this.center.add(this.bodies[0].speed.project(this.right).scale(100)), 0.025, [1, 0, 1, 1]);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/kart.ts?");

/***/ }),

/***/ "./src/objects/player.ts":
/*!*******************************!*\
  !*** ./src/objects/player.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stage1 */ \"./src/objects/stage1.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Player extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.posPrev = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        this.speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        this.radius = 0.15;\r\n        this.collisionPos = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n    }\r\n    init() {\r\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__.default();\r\n        builder.addSphere(-this.radius, -this.radius, -this.radius, this.radius, this.radius, this.radius);\r\n        builder.calculateNormals();\r\n        this.model = builder.makeModel(this.director.gl);\r\n        this.posPrev = this.position;\r\n    }\r\n    process() {\r\n        this.handleMovement();\r\n        this.handleJump();\r\n        this.handleCollision();\r\n        this.posPrev = this.position;\r\n    }\r\n    handleMovement() {\r\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\r\n        if (!camera)\r\n            return;\r\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\r\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(forward.y, -forward.x, 0);\r\n        const accel = 0.005;\r\n        const decel = 0.015;\r\n        const maxSpeed = 0.05;\r\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        if (this.director.keysHeld.has(\"arrowup\") ||\r\n            this.director.keysHeld.has(\"w\"))\r\n            moveVec.y += 1;\r\n        if (this.director.keysHeld.has(\"arrowdown\") ||\r\n            this.director.keysHeld.has(\"s\"))\r\n            moveVec.y -= 1;\r\n        if (this.director.keysHeld.has(\"arrowleft\") ||\r\n            this.director.keysHeld.has(\"a\"))\r\n            moveVec.x -= 1;\r\n        if (this.director.keysHeld.has(\"arrowright\") ||\r\n            this.director.keysHeld.has(\"d\"))\r\n            moveVec.x += 1;\r\n        moveVec = moveVec.normalized().scale(accel);\r\n        let groundSpeed = this.speed.withZ(0);\r\n        groundSpeed = groundSpeed\r\n            .add(forward.scale(moveVec.y))\r\n            .add(sideways.scale(moveVec.x));\r\n        const speedMagn = groundSpeed.withZ(0).magn();\r\n        if (speedMagn > maxSpeed)\r\n            groundSpeed = groundSpeed.withZ(0).normalized().scale(maxSpeed);\r\n        if (moveVec.magn() == 0) {\r\n            if (speedMagn > decel)\r\n                groundSpeed = groundSpeed.sub(groundSpeed.normalized().scale(decel));\r\n            else\r\n                groundSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, groundSpeed.z);\r\n        }\r\n        this.speed = this.speed.sub(this.speed.withZ(0)).add(groundSpeed);\r\n    }\r\n    handleJump() {\r\n        this.speed = this.speed.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0.01));\r\n        if (this.director.keysDown.has(\" \")) {\r\n            this.speed = this.speed.withZ(-0.15);\r\n        }\r\n    }\r\n    handleCollision() {\r\n        const stage = this.director.objectFind(_stage1__WEBPACK_IMPORTED_MODULE_4__.Stage1);\r\n        if (!stage)\r\n            return;\r\n        this.collisionPos = this.position;\r\n        const solvedGravity = stage.collision.repel(this.position, this.position.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, this.speed.z)), this.radius);\r\n        this.position = solvedGravity.position;\r\n        if (this.position.z <= this.posPrev.z &&\r\n            this.speed.z > 0)\r\n            this.speed = this.speed.withZ(0);\r\n        const solved = stage.collision.repelAndSlide(this.position, this.position.add(this.speed.withZ(0)), this.radius);\r\n        this.position = solved.position;\r\n    }\r\n    render() {\r\n        this.director.scene.pushTranslationScale(this.position, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, 1, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        /*this.director.scene.pushTranslationScale(this.collisionPos, this.scale)\r\n        this.director.scene.drawModel(\r\n            this.model,\r\n            this.director.scene.materialColor,\r\n            [1, 0, 0, 1])\r\n        this.director.scene.popTranslationScale()*/\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/player.ts?");

/***/ }),

/***/ "./src/objects/sphere.ts":
/*!*******************************!*\
  !*** ./src/objects/sphere.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sphere\": () => (/* binding */ Sphere)\n/* harmony export */ });\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\r\n\r\nclass Sphere {\r\n    constructor() {\r\n        this.id = 0;\r\n        this.pos = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0);\r\n        this.posPrev = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0);\r\n        this.speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0);\r\n        this.instantSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0);\r\n        this.radius = 0.15;\r\n        this.touchingGround = false;\r\n    }\r\n    init(director) {\r\n        this.director = director;\r\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.default();\r\n        builder.addSphere(-1, -1, -1, 1, 1, 1);\r\n        builder.calculateNormals();\r\n        this.model = builder.makeModel(this.director.gl);\r\n    }\r\n    processGravity() {\r\n        this.speed = this.speed.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0.0025));\r\n    }\r\n    processCollision(collision) {\r\n        this.touchingGround = false;\r\n        this.posPrev = this.pos;\r\n        const posPlusGravity = this.pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, this.speed.z));\r\n        const solvedGravity = collision.repel(this.pos, posPlusGravity, this.radius);\r\n        this.pos = solvedGravity.position;\r\n        const solved = collision.repelAndSlide(this.pos, this.pos.add(this.speed.withZ(0)), this.radius);\r\n        this.pos = solved.position;\r\n        this.speed = this.pos.sub(this.posPrev);\r\n        if (this.instantSpeed.magn() != 0) {\r\n            const solvedInstant = collision.repel(this.pos, this.pos.add(this.instantSpeed), this.radius);\r\n            this.pos = solvedInstant.position;\r\n        }\r\n        this.instantSpeed = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0);\r\n        const groundCheckDist = 0.1;\r\n        const solvedGroundTest = collision.repel(this.pos, this.pos.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, this.radius + groundCheckDist)), this.radius);\r\n        if (solvedGroundTest.position.z <= this.pos.z + groundCheckDist)\r\n            this.touchingGround = true;\r\n        if (false) //(this.id == 0)\r\n         {}\r\n    }\r\n    render() {\r\n        this.director.scene.pushTranslationScale(this.pos, new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(this.radius, this.radius, this.radius).scale(0.5));\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, this.touchingGround ? 1 : 0, 1]);\r\n        this.director.scene.popTranslationScale();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/sphere.ts?");

/***/ }),

/***/ "./src/objects/stage.ts":
/*!******************************!*\
  !*** ./src/objects/stage.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stage\": () => (/* binding */ Stage)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n\r\nclass Stage extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    init() {\r\n    }\r\n    setModel(gl, builder) {\r\n        this.model = builder.makeModel(gl);\r\n        this.collision = builder.makeCollision();\r\n        console.log(this.collision.triangles);\r\n    }\r\n    render() {\r\n        this.director.scene.pushTranslationScale(this.position, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [0.1, 0.75, 1, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        return;\r\n        for (const tri of this.collision.triangles) {\r\n            this.director.scene.drawArrow(tri.centroid, tri.centroid.add(tri.normal.scale(0.1)), 0.025, [1, 0, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v1, tri.v1.add(tri.normal.scale(0.1)), 0.025, [0, 0, 1, 1]);\r\n            this.director.scene.drawArrow(tri.v2, tri.v2.add(tri.normal.scale(0.1)), 0.025, [0, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v1to2Center, tri.v1to2Center.add(tri.v1to2Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v2to3Center, tri.v2to3Center.add(tri.v2to3Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v3to1Center, tri.v3to1Center.add(tri.v3to1Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/stage.ts?");

/***/ }),

/***/ "./src/objects/stage1.ts":
/*!*******************************!*\
  !*** ./src/objects/stage1.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stage1\": () => (/* binding */ Stage1)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\r\n\r\n\r\nclass Stage1 extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    init() {\r\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.default();\r\n        builder.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-10, -10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(10, -10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(10, 10, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-10, 10, 0));\r\n        builder.addCube(-5, -5, -1, -2, -2, 1);\r\n        builder.addCube(-7, -5, -2, -5, -2, 1);\r\n        builder.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-2, -5, -1), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, -5, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, -2, 0), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(-2, -2, -1));\r\n        builder.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(0, -2, -0.5), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(2, -1, -0.75), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(1, 2, -0.5));\r\n        builder.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(2, -1, -0.75), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(2, 2, -0.25), new _math_vec3__WEBPACK_IMPORTED_MODULE_2__.default(1, 2, -0.5));\r\n        builder.calculateNormals();\r\n        this.model = builder.makeModel(this.director.gl);\r\n        this.collision = builder.makeCollision();\r\n    }\r\n    render() {\r\n        this.director.scene.pushTranslationScale(this.position, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [0.1, 0.75, 1, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        for (const tri of this.collision.triangles) {\r\n            this.director.scene.drawArrow(tri.centroid, tri.centroid.add(tri.normal.scale(0.1)), 0.025, [1, 0, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v1, tri.v1.add(tri.normal.scale(0.1)), 0.025, [0, 0, 1, 1]);\r\n            this.director.scene.drawArrow(tri.v2, tri.v2.add(tri.normal.scale(0.1)), 0.025, [0, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v1to2Center, tri.v1to2Center.add(tri.v1to2Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v2to3Center, tri.v2to3Center.add(tri.v2to3Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n            this.director.scene.drawArrow(tri.v3to1Center, tri.v3to1Center.add(tri.v3to1Normal.scale(0.1)), 0.025, [1, 1, 0, 1]);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/stage1.ts?");

/***/ }),

/***/ "./src/objects/test.ts":
/*!*****************************!*\
  !*** ./src/objects/test.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Test\": () => (/* binding */ Test)\n/* harmony export */ });\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object */ \"./src/objects/_object.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/objects/camera.ts\");\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stage1 */ \"./src/objects/stage1.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Test extends _object__WEBPACK_IMPORTED_MODULE_0__.Object {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.position2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        this.speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        this.speed2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        this.radius = 0.15;\r\n    }\r\n    init() {\r\n        const builder = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_2__.default();\r\n        builder.addSphere(-this.radius, -this.radius, -this.radius, this.radius, this.radius, this.radius);\r\n        builder.calculateNormals();\r\n        this.model = builder.makeModel(this.director.gl);\r\n        this.position2 = this.position.add(new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 1));\r\n    }\r\n    process() {\r\n        this.handleMovement1();\r\n        this.handleMovement2();\r\n        this.position = this.position.add(this.speed);\r\n        this.position2 = this.position2.add(this.speed);\r\n        this.position2 = this.position2.add(this.speed2);\r\n    }\r\n    handleMovement1() {\r\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\r\n        if (!camera)\r\n            return;\r\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\r\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(forward.y, -forward.x, 0);\r\n        const up = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, -1);\r\n        const accel = 0.005;\r\n        const decel = 0.015;\r\n        const maxSpeed = 0.05;\r\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        if (!this.director.keysHeld.has(\"z\")) {\r\n            if (this.director.keysHeld.has(\"arrowup\") ||\r\n                this.director.keysHeld.has(\"w\"))\r\n                moveVec.y += 1;\r\n            if (this.director.keysHeld.has(\"arrowdown\") ||\r\n                this.director.keysHeld.has(\"s\"))\r\n                moveVec.y -= 1;\r\n            if (this.director.keysHeld.has(\"arrowleft\") ||\r\n                this.director.keysHeld.has(\"a\"))\r\n                moveVec.x -= 1;\r\n            if (this.director.keysHeld.has(\"arrowright\") ||\r\n                this.director.keysHeld.has(\"d\"))\r\n                moveVec.x += 1;\r\n            if (this.director.keysHeld.has(\"q\"))\r\n                moveVec.z -= 1;\r\n            if (this.director.keysHeld.has(\"e\"))\r\n                moveVec.z += 1;\r\n        }\r\n        moveVec = moveVec.normalized().scale(accel);\r\n        this.speed = this.speed\r\n            .add(forward.scale(moveVec.y))\r\n            .add(sideways.scale(moveVec.x))\r\n            .add(up.scale(moveVec.z));\r\n        const speedMagn = this.speed.magn();\r\n        if (speedMagn > maxSpeed)\r\n            this.speed = this.speed.normalized().scale(maxSpeed);\r\n        if (moveVec.magn() == 0) {\r\n            if (speedMagn > decel)\r\n                this.speed = this.speed.sub(this.speed.normalized().scale(decel));\r\n            else\r\n                this.speed = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        }\r\n    }\r\n    handleMovement2() {\r\n        const camera = this.director.objectFind(_camera__WEBPACK_IMPORTED_MODULE_1__.Camera);\r\n        if (!camera)\r\n            return;\r\n        const forward = camera.lookAt.sub(camera.position).withZ(0).normalized();\r\n        const sideways = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(forward.y, -forward.x, 0);\r\n        const up = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, -1);\r\n        const accel = 0.005;\r\n        const decel = 0.015;\r\n        const maxSpeed = 0.05;\r\n        let moveVec = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        if (this.director.keysHeld.has(\"z\")) {\r\n            if (this.director.keysHeld.has(\"arrowup\") ||\r\n                this.director.keysHeld.has(\"w\"))\r\n                moveVec.y += 1;\r\n            if (this.director.keysHeld.has(\"arrowdown\") ||\r\n                this.director.keysHeld.has(\"s\"))\r\n                moveVec.y -= 1;\r\n            if (this.director.keysHeld.has(\"arrowleft\") ||\r\n                this.director.keysHeld.has(\"a\"))\r\n                moveVec.x -= 1;\r\n            if (this.director.keysHeld.has(\"arrowright\") ||\r\n                this.director.keysHeld.has(\"d\"))\r\n                moveVec.x += 1;\r\n            if (this.director.keysHeld.has(\"q\"))\r\n                moveVec.z -= 1;\r\n            if (this.director.keysHeld.has(\"e\"))\r\n                moveVec.z += 1;\r\n        }\r\n        moveVec = moveVec.normalized().scale(accel);\r\n        this.speed2 = this.speed2\r\n            .add(forward.scale(moveVec.y))\r\n            .add(sideways.scale(moveVec.x))\r\n            .add(up.scale(moveVec.z));\r\n        const speedMagn = this.speed2.magn();\r\n        if (speedMagn > maxSpeed)\r\n            this.speed2 = this.speed2.normalized().scale(maxSpeed);\r\n        if (moveVec.magn() == 0) {\r\n            if (speedMagn > decel)\r\n                this.speed2 = this.speed2.sub(this.speed2.normalized().scale(decel));\r\n            else\r\n                this.speed2 = new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0);\r\n        }\r\n    }\r\n    render() {\r\n        const stage = this.director.objectFind(_stage1__WEBPACK_IMPORTED_MODULE_4__.Stage1);\r\n        if (!stage)\r\n            return;\r\n        const fromPos = this.position;\r\n        const toPos = this.position2;\r\n        const solved = stage.collision.repel(fromPos, toPos, this.radius);\r\n        const solvedSlide = stage.collision.repelAndSlide(fromPos, toPos, this.radius);\r\n        this.director.scene.pushTranslationScale(fromPos, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0, 0, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        this.director.scene.pushTranslationScale(solved.position, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0.5, 0, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        this.director.scene.pushTranslationScale(solvedSlide.position, this.scale);\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 1, 0, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        this.director.scene.pushTranslationScale(solved.contact, new _math_vec3__WEBPACK_IMPORTED_MODULE_3__.default(0.25, 0.25, 0.25));\r\n        this.director.scene.drawModel(this.model, this.director.scene.materialColor, [1, 0, 0, 1]);\r\n        this.director.scene.popTranslationScale();\r\n        this.director.scene.drawArrow(fromPos, toPos, 0.025, [1, 0, 0, 1]);\r\n        this.director.scene.drawArrow(fromPos, solvedSlide.position, 0.025, [1, 0.5, 1, 1]);\r\n        this.director.scene.drawArrow(fromPos, solvedSlide.position, 0.025, [1, 1, 0, 1]);\r\n        this.director.scene.drawArrow(solved.position, solvedSlide.position, 0.025, [1, 1, 1, 1]);\r\n        this.director.scene.drawArrow(solved.position, solved.position.add(solved.position.sub(solved.contact).scale(this.scale.x * 2)), 0.025, [1, 0, 0, 1]);\r\n        /*this.director.scene.pushTranslationScale(solved.position.add(slide), this.scale)\r\n        this.director.scene.drawModel(\r\n            this.model,\r\n            this.director.scene.materialColor,\r\n            [0, 1, 0, 1])\r\n        this.director.scene.popTranslationScale()\r\n        \r\n        this.director.scene.drawArrow(\r\n            solved.position,\r\n            solved.position.add(slide),\r\n            0.025,\r\n            [0, 1, 0, 1])\r\n\r\n        for (const tri of stage.collision.triangles)\r\n        {\r\n            const direction = this.position.directionToPlane(tri.normal, tri.v1)\r\n\r\n            this.director.scene.drawArrow(\r\n                this.position,\r\n                this.position.add(direction),\r\n                0.025,\r\n                [0, 1, 1, 1])\r\n        }*/\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/objects/test.ts?");

/***/ }),

/***/ "./src/util/collisionMesh.ts":
/*!***********************************!*\
  !*** ./src/util/collisionMesh.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollisionMesh)\n/* harmony export */ });\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/geometry */ \"./src/math/geometry.ts\");\n\r\n\r\nconst buckets = 50;\r\nclass CollisionMesh {\r\n    constructor() {\r\n        this.xMin = 0;\r\n        this.xMax = 0;\r\n        this.yMin = 0;\r\n        this.yMax = 0;\r\n        this.triangles = [];\r\n        this.triangleBuckets = [];\r\n        for (let j = 0; j < buckets; j++) {\r\n            this.triangleBuckets.push([]);\r\n            for (let i = 0; i < buckets; i++)\r\n                this.triangleBuckets[j].push([]);\r\n        }\r\n    }\r\n    addTri(v1, v2, v3) {\r\n        const v1to2 = v2.sub(v1);\r\n        const v1to3 = v3.sub(v1);\r\n        const v2to3 = v3.sub(v2);\r\n        const v3to1 = v1.sub(v3);\r\n        const normal = v1to2.cross(v3to1).normalized();\r\n        const v1to2Normal = normal.cross(v1to2).normalized();\r\n        const v2to3Normal = normal.cross(v2to3).normalized();\r\n        const v3to1Normal = normal.cross(v3to1).normalized();\r\n        const centroid = new _math_vec3__WEBPACK_IMPORTED_MODULE_0__.default((v1.x + v2.x + v3.x) / 3, (v1.y + v2.y + v3.y) / 3, (v1.z + v2.z + v3.z) / 3);\r\n        const v1to2Center = v1.lerp(v2, 0.5);\r\n        const v2to3Center = v2.lerp(v3, 0.5);\r\n        const v3to1Center = v3.lerp(v1, 0.5);\r\n        const tri = {\r\n            index: this.triangles.length,\r\n            v1, v2, v3, v1to2, v1to3, v2to3, v3to1,\r\n            normal, v1to2Normal, v3to1Normal, v2to3Normal,\r\n            centroid, v1to2Center, v3to1Center, v2to3Center,\r\n        };\r\n        this.triangles.push(tri);\r\n        this.xMin = Math.min(this.xMin, v1.x, v2.x, v3.x);\r\n        this.xMax = Math.max(this.xMax, v1.x, v2.x, v3.x);\r\n        this.yMin = Math.min(this.yMin, v1.y, v2.y, v3.y);\r\n        this.yMax = Math.max(this.yMax, v1.y, v2.y, v3.y);\r\n    }\r\n    build() {\r\n        for (const tri of this.triangles) {\r\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v1));\r\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v2));\r\n            this.addToNearBuckets(tri, this.bucketForPosition(tri.v3));\r\n        }\r\n    }\r\n    addToNearBuckets(tri, bucketIndex) {\r\n        this.addToBucket(tri, bucketIndex);\r\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y });\r\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y });\r\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y - 1 });\r\n        this.addToBucket(tri, { x: bucketIndex.x + 0, y: bucketIndex.y - 1 });\r\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y - 1 });\r\n        this.addToBucket(tri, { x: bucketIndex.x - 1, y: bucketIndex.y + 1 });\r\n        this.addToBucket(tri, { x: bucketIndex.x + 0, y: bucketIndex.y + 1 });\r\n        this.addToBucket(tri, { x: bucketIndex.x + 1, y: bucketIndex.y + 1 });\r\n    }\r\n    addToBucket(tri, bucketIndex) {\r\n        if (bucketIndex.x < 0 || bucketIndex.x >= buckets)\r\n            return;\r\n        if (bucketIndex.y < 0 || bucketIndex.y >= buckets)\r\n            return;\r\n        const bucket = this.triangleBuckets[bucketIndex.y][bucketIndex.x];\r\n        if (!bucket.find(t => t === tri))\r\n            bucket.push(tri);\r\n    }\r\n    bucketForPosition(pos) {\r\n        const x = Math.max(0, Math.floor((pos.x - this.xMin) / (this.xMax - this.xMin) * buckets) % buckets);\r\n        const y = Math.max(0, Math.floor((pos.y - this.yMin) / (this.yMax - this.yMin) * buckets) % buckets);\r\n        return { x, y };\r\n    }\r\n    *enumerateTrianglesByBuckets(pos) {\r\n        const bucketIndex = this.bucketForPosition(pos);\r\n        for (const tri of this.triangleBuckets[bucketIndex.y][bucketIndex.x])\r\n            yield tri;\r\n    }\r\n    repelAndSlide(posPrev, pos, radius) {\r\n        let contact = pos;\r\n        let collided = false;\r\n        for (let i = 0; i < 2; i++) {\r\n            const solved = this.repel(posPrev, pos, radius);\r\n            posPrev = solved.position;\r\n            if (!solved.collided)\r\n                break;\r\n            collided = true;\r\n            contact = solved.contact;\r\n            const slideVec = pos.sub(solved.position).projectOnPlane(solved.position.sub(solved.contact));\r\n            pos = posPrev.add(slideVec);\r\n        }\r\n        return {\r\n            position: posPrev,\r\n            contact,\r\n            collided,\r\n        };\r\n    }\r\n    collideAndSlide(posPrev, pos, radius) {\r\n        let contact = pos;\r\n        let collided = false;\r\n        for (let i = 0; i < 3; i++) {\r\n            const solved = this.collide(posPrev, pos, radius);\r\n            posPrev = solved.position;\r\n            if (!solved.collided)\r\n                break;\r\n            collided = true;\r\n            contact = solved.contact;\r\n            const extraSpeed = pos.sub(solved.position);\r\n            const slideVec = extraSpeed.projectOnPlane(solved.position.sub(solved.contact));\r\n            pos = posPrev.add(slideVec);\r\n        }\r\n        return {\r\n            position: posPrev,\r\n            contact,\r\n            collided,\r\n        };\r\n    }\r\n    repel(posPrev, pos, radius) {\r\n        let solvedPos = pos;\r\n        let solvedT = Infinity;\r\n        let contact = pos;\r\n        let collided = false;\r\n        for (const tri of this.enumerateTrianglesByBuckets(pos)) {\r\n            const triSolved = this.repelTriangle(tri, posPrev, pos, radius);\r\n            if (!triSolved)\r\n                continue;\r\n            const triSolvedT = triSolved.position.sub(posPrev).projectT(pos.sub(posPrev));\r\n            if (triSolvedT < solvedT) {\r\n                solvedPos = triSolved.position;\r\n                solvedT = triSolvedT;\r\n                contact = triSolved.contact;\r\n                collided = true;\r\n            }\r\n        }\r\n        return {\r\n            position: solvedPos,\r\n            contact,\r\n            collided,\r\n        };\r\n    }\r\n    collide(posPrev, pos, radius) {\r\n        let t = 1;\r\n        let contact = pos;\r\n        for (const tri of this.triangles) {\r\n            const triSolved = this.collideTriangle(tri, posPrev, pos, radius);\r\n            if (!triSolved)\r\n                continue;\r\n            if (triSolved.t < t) {\r\n                t = triSolved.t;\r\n                contact = triSolved.contact;\r\n            }\r\n        }\r\n        return {\r\n            position: posPrev.add(pos.sub(posPrev).scale(t)),\r\n            contact,\r\n            collided: t < 1,\r\n        };\r\n    }\r\n    repelTriangle(tri, posPrev, pos, radius) {\r\n        const speed = pos.sub(posPrev);\r\n        const speedNorm = speed.normalized();\r\n        const sqrRadius = radius * radius;\r\n        const sqrDistPlanePrev = posPrev.signedSqrDistanceToPlane(tri.normal, tri.v1);\r\n        if (sqrDistPlanePrev <= -sqrRadius)\r\n            return null;\r\n        const sqrDistPlane = pos.signedSqrDistanceToPlane(tri.normal, tri.v1);\r\n        if (sqrDistPlane >= sqrRadius)\r\n            return null;\r\n        //const sqrDistEdge1 = pos.signedSqrDistanceToPlane(tri.v1to2Normal, tri.v1)\r\n        //const sqrDistEdge2 = pos.signedSqrDistanceToPlane(tri.v2to3Normal, tri.v2)\r\n        //const sqrDistEdge3 = pos.signedSqrDistanceToPlane(tri.v3to1Normal, tri.v3)\r\n        const sqrDistEdge1 = pos.signedSqrDistanceToPlane(tri.v1to2.normalized().cross(speedNorm), tri.v1);\r\n        const sqrDistEdge2 = pos.signedSqrDistanceToPlane(tri.v2to3.normalized().cross(speedNorm), tri.v2);\r\n        const sqrDistEdge3 = pos.signedSqrDistanceToPlane(tri.v3to1.normalized().cross(speedNorm), tri.v3);\r\n        if (sqrDistEdge1 >= sqrRadius || sqrDistEdge2 >= sqrRadius || sqrDistEdge3 >= sqrRadius)\r\n            return null;\r\n        const repelledFromSpeed = speed; //Math.sqrt(Math.abs(sqrDistPlane)) + radius * 2)\r\n        const repelledFromPos = pos.sub(repelledFromSpeed);\r\n        const repelledCollision = this.collideTriangle(tri, repelledFromPos, repelledFromPos.add(repelledFromSpeed), radius);\r\n        if (!repelledCollision)\r\n            return null;\r\n        return {\r\n            position: repelledFromPos.add(repelledFromSpeed.scale(repelledCollision.t).withAddedMagn(-radius * 0.01)),\r\n            contact: repelledCollision.contact,\r\n        };\r\n    }\r\n    collideTriangle(tri, posPrev, pos, radius) {\r\n        const radiusNormal = tri.normal.scale(radius);\r\n        const speed = pos.sub(posPrev);\r\n        const dotPrevNormal = tri.normal.dot(posPrev.sub(radiusNormal).sub(tri.v1));\r\n        //console.log(\"dotPrevNormal\", dotPrevNormal)\r\n        //if (dotPrevNormal < 0)\r\n        //\treturn null\r\n        const dotNormal = tri.normal.dot(pos.sub(radiusNormal).sub(tri.v1));\r\n        //console.log(\"dotNormal\", dotNormal)\r\n        //if (dotNormal > 0)\r\n        //\treturn null\r\n        const speedDotNormal = tri.normal.dot(speed);\r\n        let tPlane = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPlane(posPrev, speed, radius, tri.v1, tri.normal);\r\n        const contactPlane = posPrev.sub(tri.normal.scale(radius)).add(speed.scale(tPlane));\r\n        const dotPlane1 = contactPlane.sub(tri.v1).dot(tri.v1to2Normal);\r\n        const dotPlane2 = contactPlane.sub(tri.v2).dot(tri.v2to3Normal);\r\n        const dotPlane3 = contactPlane.sub(tri.v3).dot(tri.v3to1Normal);\r\n        if (dotPlane1 > 0 || dotPlane2 > 0 || dotPlane3 > 0)\r\n            tPlane = Infinity;\r\n        const tE1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v1, tri.v1to2);\r\n        const tE2 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v2, tri.v2to3);\r\n        const tE3 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToSegment(posPrev, speed, radius, tri.v3, tri.v3to1);\r\n        const tV1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v1);\r\n        const tV2 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v2);\r\n        const tV3 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.sweepSphereToPoint(posPrev, speed, radius, tri.v3);\r\n        const t = Math.min(tPlane, tE1, tE2, tE3, tV1, tV2, tV3);\r\n        //if (speedDotNormal >= 0 && (t < 0 || t > 1))\r\n        //\treturn null\r\n        //if (speedDotNormal < 0 && (t < -0.5 || t > 1))\r\n        //\treturn null\r\n        if (t < 0 || t > 1)\r\n            return null;\r\n        if (!isFinite(t))\r\n            return null;\r\n        if (tPlane < tE1 && tPlane < tE2 && tPlane < tE3 && tPlane < tV1 && tPlane < tV2 && tPlane < tV3)\r\n            return { t: tPlane, contact: contactPlane };\r\n        if (tE1 < tE2 && tE1 < tE3 && tE1 < tV1 && tE1 < tV2 && tE1 < tV3) {\r\n            const pE1 = posPrev.add(speed.scale(tE1));\r\n            return { t: tE1, contact: pE1.sub(pE1.directionToLine(tri.v1to2, tri.v1)) };\r\n        }\r\n        if (tE2 < tE3 && tE2 < tV1 && tE2 < tV2 && tE2 < tV3) {\r\n            const pE2 = posPrev.add(speed.scale(tE2));\r\n            return { t: tE2, contact: pE2.sub(pE2.directionToLine(tri.v2to3, tri.v2)) };\r\n        }\r\n        if (tE3 < tV1 && tE3 < tV2 && tE3 < tV3) {\r\n            const pE3 = posPrev.add(speed.scale(tE3));\r\n            return { t: tE3, contact: pE3.sub(pE3.directionToLine(tri.v3to1, tri.v3)) };\r\n        }\r\n        if (tV1 < tV2 && tE3 < tV3) {\r\n            return { t: tV1, contact: tri.v1 };\r\n        }\r\n        if (tV2 < tV3) {\r\n            return { t: tV2, contact: tri.v2 };\r\n        }\r\n        return { t: tV3, contact: tri.v3 };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/util/collisionMesh.ts?");

/***/ }),

/***/ "./src/util/modelBuilder.ts":
/*!**********************************!*\
  !*** ./src/util/modelBuilder.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ModelBuilder)\n/* harmony export */ });\n/* harmony import */ var _gl_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gl/model */ \"./src/gl/model.ts\");\n/* harmony import */ var _gl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gl/buffer */ \"./src/gl/buffer.ts\");\n/* harmony import */ var _collisionMesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collisionMesh */ \"./src/util/collisionMesh.ts\");\n/* harmony import */ var _math_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/mat4 */ \"./src/math/mat4.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\r\n\r\n\r\n\r\n\r\nclass ModelBuilder {\r\n    constructor() {\r\n        this.positions = [];\r\n        this.normals = [];\r\n        this.colors = [];\r\n    }\r\n    addTri(v1, v2, v3, c1, c2, c3) {\r\n        this.positions.push(v1);\r\n        this.positions.push(v2);\r\n        this.positions.push(v3);\r\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, 0));\r\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, 0));\r\n        this.normals.push(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, 0));\r\n        this.colors.push(c1 ? c1 : [1, 1, 1, 1]);\r\n        this.colors.push(c2 ? c2 : [1, 1, 1, 1]);\r\n        this.colors.push(c3 ? c3 : [1, 1, 1, 1]);\r\n        return this;\r\n    }\r\n    addQuad(v1, v2, v3, v4, c1, c2, c3, c4) {\r\n        this.addTri(v1, v2, v3, c1, c2, c3);\r\n        this.addTri(v1, v3, v4, c1, c3, c4);\r\n        return this;\r\n    }\r\n    addQuadSubdiv(v1, v2, v3, v4, subdivs) {\r\n        for (let j = 0; j < subdivs; j++) {\r\n            for (let i = 0; i < subdivs; i++) {\r\n                let p1 = v1.lerp(v2, (i + 0) / subdivs);\r\n                let p2 = v1.lerp(v2, (i + 1) / subdivs);\r\n                let p3 = v4.lerp(v3, (i + 1) / subdivs);\r\n                let p4 = v4.lerp(v3, (i + 0) / subdivs);\r\n                let f1 = p1.lerp(p4, (j + 0) / subdivs);\r\n                let f2 = p2.lerp(p3, (j + 0) / subdivs);\r\n                let f3 = p2.lerp(p3, (j + 1) / subdivs);\r\n                let f4 = p1.lerp(p4, (j + 1) / subdivs);\r\n                this.addQuad(f1, f2, f3, f4);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    addCube(x1, y1, z1, x2, y2, z2, subdivs = 1) {\r\n        let v1Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x1, y1, z1);\r\n        let v2Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x2, y1, z1);\r\n        let v3Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x2, y2, z1);\r\n        let v4Top = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x1, y2, z1);\r\n        let v1Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x1, y1, z2);\r\n        let v2Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x2, y1, z2);\r\n        let v3Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x2, y2, z2);\r\n        let v4Bot = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(x1, y2, z2);\r\n        this.addQuadSubdiv(v1Top, v2Top, v3Top, v4Top, subdivs);\r\n        this.addQuadSubdiv(v1Bot, v4Bot, v3Bot, v2Bot, subdivs);\r\n        this.addQuadSubdiv(v2Top, v1Top, v1Bot, v2Bot, subdivs);\r\n        this.addQuadSubdiv(v3Top, v2Top, v2Bot, v3Bot, subdivs);\r\n        this.addQuadSubdiv(v4Top, v3Top, v3Bot, v4Bot, subdivs);\r\n        this.addQuadSubdiv(v1Top, v4Top, v4Bot, v1Bot, subdivs);\r\n        return this;\r\n    }\r\n    addSphere(x1, y1, z1, x2, y2, z2, subdivs = 8) {\r\n        let index = this.positions.length;\r\n        this.addCube(x1, y1, z1, x2, y2, z2, subdivs);\r\n        let c = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default((x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);\r\n        let size = new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(Math.abs(x2 - x1) / 2, Math.abs(y2 - y1) / 2, Math.abs(z2 - z1) / 2);\r\n        for (let i = index; i < this.positions.length; i++)\r\n            this.positions[i] = c.add(this.positions[i].sub(c).normalized().mul(size));\r\n        return this;\r\n    }\r\n    addCone(x1, y1, z1, x2, y2, z2, subdivs = 8, upVec) {\r\n        let index = this.positions.length;\r\n        let cx = (x1 + x2) / 2;\r\n        let cy = (y1 + y2) / 2;\r\n        let sx = (x2 - x1) / 2;\r\n        let sy = (y2 - y1) / 2;\r\n        for (let i = 0; i < subdivs; i++) {\r\n            let angle0 = (i + 0) / subdivs * Math.PI * 2;\r\n            let angle1 = (i + 1) / subdivs * Math.PI * 2;\r\n            let cos0 = Math.cos(angle0);\r\n            let cos1 = Math.cos(angle1);\r\n            let sin0 = Math.sin(angle0);\r\n            let sin1 = Math.sin(angle1);\r\n            // Lid\r\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx, cy, z1));\r\n            // Edge\r\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx, cy, z2));\r\n        }\r\n        if (upVec != null) {\r\n            let matrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__.default.rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, -1), upVec);\r\n            for (let i = index; i < this.positions.length; i++)\r\n                this.positions[i] = matrix.mulPoint(this.positions[i]);\r\n        }\r\n        return this;\r\n    }\r\n    addCylinder(x1, y1, z1, x2, y2, z2, subdivs = 8, upVec) {\r\n        let index = this.positions.length;\r\n        let cx = (x1 + x2) / 2;\r\n        let cy = (y1 + y2) / 2;\r\n        let sx = (x2 - x1) / 2;\r\n        let sy = (y2 - y1) / 2;\r\n        for (let i = 0; i < subdivs; i++) {\r\n            let angle0 = (i + 0) / subdivs * Math.PI * 2;\r\n            let angle1 = (i + 1) / subdivs * Math.PI * 2;\r\n            let cos0 = Math.cos(angle0);\r\n            let cos1 = Math.cos(angle1);\r\n            let sin0 = Math.sin(angle0);\r\n            let sin1 = Math.sin(angle1);\r\n            // Lid\r\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx, cy, z1));\r\n            // Bottom\r\n            this.addTri(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx, cy, z2));\r\n            // Edge\r\n            this.addQuad(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z1), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos0 * sx, cy + sin0 * sy, z2), new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(cx + cos1 * sx, cy + sin1 * sy, z2));\r\n        }\r\n        if (upVec != null) {\r\n            let matrix = _math_mat4__WEBPACK_IMPORTED_MODULE_3__.default.rotationFromTo(new _math_vec3__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, -1), upVec);\r\n            for (let i = index; i < this.positions.length; i++)\r\n                this.positions[i] = matrix.mulPoint(this.positions[i]);\r\n        }\r\n        return this;\r\n    }\r\n    /*getBoundingBox()\r\n    {\r\n        let bbox =\r\n        {\r\n            xMin: null,\r\n            yMin: null,\r\n            zMin: null,\r\n            xMax: null,\r\n            yMax: null,\r\n            zMax: null\r\n        }\r\n        \r\n        for (let pos of this.positions)\r\n        {\r\n            bbox.xMin = (bbox.xMin == null ? pos.x : Math.min(bbox.xMin, pos.x))\r\n            bbox.yMin = (bbox.xMin == null ? pos.y : Math.min(bbox.yMin, pos.y))\r\n            bbox.zMin = (bbox.xMin == null ? pos.z : Math.min(bbox.zMin, pos.z))\r\n            bbox.xMax = (bbox.xMax == null ? pos.x : Math.max(bbox.xMax, pos.x))\r\n            bbox.yMax = (bbox.xMax == null ? pos.y : Math.max(bbox.yMax, pos.y))\r\n            bbox.zMax = (bbox.xMax == null ? pos.z : Math.max(bbox.zMax, pos.z))\r\n        }\r\n        \r\n        bbox.xSize = (bbox.xMax - bbox.xMin)\r\n        bbox.ySize = (bbox.yMax - bbox.yMin)\r\n        bbox.zSize = (bbox.zMax - bbox.zMin)\r\n        \r\n        bbox.xCenter = (bbox.xMin + bbox.xMax) / 2\r\n        bbox.yCenter = (bbox.yMin + bbox.yMax) / 2\r\n        bbox.zCenter = (bbox.zMin + bbox.zMax) / 2\r\n        \r\n        return bbox\r\n    }\r\n    \r\n    \r\n    getSaneBoundingBox(maxSize: number = 100000)\r\n    {\r\n        let center = this.getMedianCenter()\r\n        \r\n        let bbox =\r\n        {\r\n            xMin: null,\r\n            yMin: null,\r\n            zMin: null,\r\n            xMax: null,\r\n            yMax: null,\r\n            zMax: null\r\n        }\r\n        \r\n        for (let pos of this.positions)\r\n        {\r\n            if (Math.abs(pos.x - center.x) < maxSize)\r\n            {\r\n                bbox.xMin = (bbox.xMin == null ? pos.x : Math.min(bbox.xMin, pos.x))\r\n                bbox.xMax = (bbox.xMax == null ? pos.x : Math.max(bbox.xMax, pos.x))\r\n            }\r\n            \r\n            if (Math.abs(pos.y - center.y) < maxSize)\r\n            {\r\n                bbox.yMin = (bbox.xMin == null ? pos.y : Math.min(bbox.yMin, pos.y))\r\n                bbox.yMax = (bbox.xMax == null ? pos.y : Math.max(bbox.yMax, pos.y))\r\n            }\r\n            \r\n            if (Math.abs(pos.z - center.z) < maxSize)\r\n            {\r\n                bbox.zMin = (bbox.xMin == null ? pos.z : Math.min(bbox.zMin, pos.z))\r\n                bbox.zMax = (bbox.xMax == null ? pos.z : Math.max(bbox.zMax, pos.z))\r\n            }\r\n        }\r\n        \r\n        bbox.xSize = (bbox.xMax - bbox.xMin)\r\n        bbox.ySize = (bbox.yMax - bbox.yMin)\r\n        bbox.zSize = (bbox.zMax - bbox.zMin)\r\n        \r\n        bbox.xCenter = (bbox.xMin + bbox.xMax) / 2\r\n        bbox.yCenter = (bbox.yMin + bbox.yMax) / 2\r\n        bbox.zCenter = (bbox.zMin + bbox.zMax) / 2\r\n        \r\n        return bbox\r\n    }*/\r\n    getMedianCenter() {\r\n        if (this.positions.length == 0)\r\n            return { x: 0, y: 0, z: 0 };\r\n        let xs = [];\r\n        let ys = [];\r\n        let zs = [];\r\n        for (let pos of this.positions) {\r\n            xs.push(pos.x);\r\n            ys.push(pos.y);\r\n            zs.push(pos.z);\r\n        }\r\n        xs.sort((a, b) => a - b);\r\n        ys.sort((a, b) => a - b);\r\n        zs.sort((a, b) => a - b);\r\n        return {\r\n            x: xs[Math.floor(xs.length / 2)],\r\n            y: ys[Math.floor(xs.length / 2)],\r\n            z: zs[Math.floor(xs.length / 2)]\r\n        };\r\n    }\r\n    makeDoubleSided() {\r\n        let len = this.positions.length;\r\n        for (let i = 0; i < len; i += 3) {\r\n            let v1 = this.positions[i + 0];\r\n            let v2 = this.positions[i + 1];\r\n            let v3 = this.positions[i + 2];\r\n            this.addTri(v1, v3, v2);\r\n        }\r\n        return this;\r\n    }\r\n    calculateNormals(maxSmoothAngle = 1.5) {\r\n        for (let i = 0; i < this.positions.length; i += 3) {\r\n            let v1 = this.positions[i + 0];\r\n            let v2 = this.positions[i + 1];\r\n            let v3 = this.positions[i + 2];\r\n            let v1to2 = v2.sub(v1);\r\n            let v1to3 = v3.sub(v1);\r\n            let normal = v1to2.cross(v1to3).normalized();\r\n            this.normals[i + 0] = normal;\r\n            this.normals[i + 1] = normal;\r\n            this.normals[i + 2] = normal;\r\n        }\r\n        // Disable slow smooth-shading calculations for now\r\n        return this;\r\n        /*const rounding = 0.001\r\n        const hash = (vec) =>\r\n        {\r\n            return (\r\n                (Math.round(vec.x * rounding) / rounding) * 1000000 +\r\n                (Math.round(vec.y * rounding) / rounding) * 1000 +\r\n                (Math.round(vec.z * rounding) / rounding))\r\n        }\r\n        \r\n        let verticesSet = new Map()\r\n        for (let j = 0; j < this.positions.length; j++)\r\n        {\r\n            let key = hash(this.positions[j])\r\n            \r\n            let value = verticesSet.get(key)\r\n            if (value === undefined)\r\n                verticesSet.set(key, [j])\r\n            else\r\n                value.push(j)\r\n        }\r\n        \r\n        let normalAccum = []\r\n        let normalCount = []\r\n        for (let j = 0; j < this.positions.length; j++)\r\n        {\r\n            normalAccum[j] = this.normals[j]\r\n            normalCount[j] = 1\r\n            \r\n            let vertices = verticesSet.get(hash(this.positions[j]))\r\n            if (vertices === undefined)\r\n                continue\r\n            \r\n            for (let i of vertices)\r\n            {\r\n                if (i == j)\r\n                    continue\r\n                \r\n                if (Math.abs(Math.acos(this.normals[j].dot(this.normals[i]))) <= maxSmoothAngle)\r\n                {\r\n                    normalAccum[j] = normalAccum[j].add(this.normals[i])\r\n                    normalCount[j] += 1\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (let i = 0; i < this.positions.length; i++)\r\n            this.normals[i] = normalAccum[i].scale(1 / normalCount[i]).normalize()\r\n        \r\n        return this*/\r\n    }\r\n    makeModel(gl) {\r\n        let positions = [];\r\n        let normals = [];\r\n        let colors = [];\r\n        for (let i = 0; i < this.positions.length; i++) {\r\n            positions.push(this.positions[i].x);\r\n            positions.push(this.positions[i].y);\r\n            positions.push(this.positions[i].z);\r\n            normals.push(this.normals[i].x);\r\n            normals.push(this.normals[i].y);\r\n            normals.push(this.normals[i].z);\r\n            colors.push(this.colors[i][0]);\r\n            colors.push(this.colors[i][1]);\r\n            colors.push(this.colors[i][2]);\r\n            colors.push(this.colors[i][3]);\r\n        }\r\n        let model = new _gl_model__WEBPACK_IMPORTED_MODULE_0__.default()\r\n            .setPositions(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makePosition(gl, positions))\r\n            .setNormals(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makeNormal(gl, normals))\r\n            .setColors(_gl_buffer__WEBPACK_IMPORTED_MODULE_1__.GLBuffer.makeColor(gl, colors));\r\n        return model;\r\n    }\r\n    makeCollision() {\r\n        let col = new _collisionMesh__WEBPACK_IMPORTED_MODULE_2__.default();\r\n        for (let i = 0; i < this.positions.length; i += 3)\r\n            col.addTri(this.positions[i + 0], this.positions[i + 1], this.positions[i + 2]);\r\n        col.build();\r\n        return col;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/util/modelBuilder.ts?");

/***/ }),

/***/ "./src/util/objLoader.ts":
/*!*******************************!*\
  !*** ./src/util/objLoader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjLoader\": () => (/* binding */ ObjLoader)\n/* harmony export */ });\n/* harmony import */ var _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/modelBuilder */ \"./src/util/modelBuilder.ts\");\n/* harmony import */ var _math_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vec3 */ \"./src/math/vec3.ts\");\n\r\n\r\nclass ObjLoader {\r\n    static load(bytes) {\r\n        let str = new TextDecoder(\"utf-8\").decode(bytes);\r\n        let lines = str.replace(\"\\r\\n\", \"\\n\").split(\"\\n\").map(s => s.trim());\r\n        let objects = [];\r\n        let curObject = null;\r\n        let curGeometry = null;\r\n        for (let line of lines) {\r\n            if (line.startsWith(\"#\"))\r\n                continue;\r\n            let tagO = line.match(/^o[ ]+(.*)/);\r\n            if (tagO != null) {\r\n                let object = {};\r\n                object.name = tagO[1];\r\n                object.vertices = [];\r\n                object.normals = [];\r\n                object.texCoords = [];\r\n                object.geometries = [];\r\n                objects.push(object);\r\n                curObject = object;\r\n                continue;\r\n            }\r\n            if (curObject == null) {\r\n                let object = {};\r\n                object.name = \"Default Object\";\r\n                object.vertices = [];\r\n                object.normals = [];\r\n                object.texCoords = [];\r\n                object.geometries = [];\r\n                objects.push(object);\r\n                curObject = object;\r\n            }\r\n            let tagV = line.match(/^v[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\r\n            if (tagV != null) {\r\n                let vertex = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(parseFloat(tagV[1]), -parseFloat(tagV[3]), -parseFloat(tagV[2]));\r\n                curObject.vertices.push(vertex);\r\n                continue;\r\n            }\r\n            let tagVT = line.match(/^vt[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\r\n            if (tagVT != null) {\r\n                let texCoord = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(parseFloat(tagVT[1]), parseFloat(tagVT[2]), 0);\r\n                curObject.texCoords.push(texCoord);\r\n                continue;\r\n            }\r\n            let tagVN = line.match(/^vn[ ]+([0-9.-]+)[ ]+([0-9.-]+)[ ]+([0-9.-]+)/);\r\n            if (tagVN != null) {\r\n                let normal = new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(parseFloat(tagVN[1]), parseFloat(tagVN[2]), parseFloat(tagVN[3]));\r\n                curObject.normals.push(normal);\r\n                continue;\r\n            }\r\n            let tagG = line.match(/^g[ ]+(.*)/);\r\n            if (tagG != null) {\r\n                let geometry = {};\r\n                geometry.name = tagG[1];\r\n                geometry.faces = [];\r\n                curObject.geometries.push(geometry);\r\n                curGeometry = geometry;\r\n                continue;\r\n            }\r\n            if (curGeometry == null)\r\n                continue;\r\n            if (line.startsWith(\"f\")) {\r\n                let splits = line.substr(1).split(\" \").map(v => v.trim());\r\n                let face = [];\r\n                for (let split of splits) {\r\n                    if (split == \"\")\r\n                        continue;\r\n                    let indices = split.split(\"/\");\r\n                    let vertex = {};\r\n                    vertex.position = curObject.vertices[parseInt(indices[0]) - 1];\r\n                    vertex.texCoord = (indices.length < 2 ? new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0) : curObject.texCoords[parseInt(indices[1]) - 1]);\r\n                    vertex.normal = (indices.length < 3 ? new _math_vec3__WEBPACK_IMPORTED_MODULE_1__.default(0, 0, 0) : curObject.normals[parseInt(indices[2]) - 1]);\r\n                    if (vertex.position)\r\n                        face.push(vertex);\r\n                }\r\n                curGeometry.faces.push(face);\r\n                continue;\r\n            }\r\n        }\r\n        return objects;\r\n    }\r\n    static makeModelBuilder(bytes) {\r\n        let objects = ObjLoader.load(bytes);\r\n        console.log(objects);\r\n        let model = new _util_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.default();\r\n        for (let object of objects) {\r\n            for (let geometry of object.geometries) {\r\n                for (let face of geometry.faces) {\r\n                    if (face.length >= 3) {\r\n                        model.addTri(face[0].position, face[1].position, face[2].position);\r\n                        model.addTri(face[0].position, face[2].position, face[1].position);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return model.calculateNormals();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://platformer/./src/util/objLoader.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;